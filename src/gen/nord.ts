// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.28.3
// source: nord.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Message } from "./common";

export const protobufPackage = "nord";

export enum Side {
  ASK = 0,
  BID = 1,
}

export function sideFromJSON(object: any): Side {
  switch (object) {
    case 0:
    case "ASK":
      return Side.ASK;
    case 1:
    case "BID":
      return Side.BID;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Side");
  }
}

export function sideToJSON(object: Side): string {
  switch (object) {
    case Side.ASK:
      return "ASK";
    case Side.BID:
      return "BID";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Side");
  }
}

export enum TriggerKind {
  STOP_LOSS = 0,
  TAKE_PROFIT = 1,
}

export function triggerKindFromJSON(object: any): TriggerKind {
  switch (object) {
    case 0:
    case "STOP_LOSS":
      return TriggerKind.STOP_LOSS;
    case 1:
    case "TAKE_PROFIT":
      return TriggerKind.TAKE_PROFIT;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TriggerKind");
  }
}

export function triggerKindToJSON(object: TriggerKind): string {
  switch (object) {
    case TriggerKind.STOP_LOSS:
      return "STOP_LOSS";
    case TriggerKind.TAKE_PROFIT:
      return "TAKE_PROFIT";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum TriggerKind");
  }
}

export enum FillMode {
  LIMIT = 0,
  POST_ONLY = 1,
  IMMEDIATE_OR_CANCEL = 2,
  FILL_OR_KILL = 3,
}

export function fillModeFromJSON(object: any): FillMode {
  switch (object) {
    case 0:
    case "LIMIT":
      return FillMode.LIMIT;
    case 1:
    case "POST_ONLY":
      return FillMode.POST_ONLY;
    case 2:
    case "IMMEDIATE_OR_CANCEL":
      return FillMode.IMMEDIATE_OR_CANCEL;
    case 3:
    case "FILL_OR_KILL":
      return FillMode.FILL_OR_KILL;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FillMode");
  }
}

export function fillModeToJSON(object: FillMode): string {
  switch (object) {
    case FillMode.LIMIT:
      return "LIMIT";
    case FillMode.POST_ONLY:
      return "POST_ONLY";
    case FillMode.IMMEDIATE_OR_CANCEL:
      return "IMMEDIATE_OR_CANCEL";
    case FillMode.FILL_OR_KILL:
      return "FILL_OR_KILL";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum FillMode");
  }
}

export enum MarketType {
  SPOT = 0,
  PERPETUALS = 1,
}

export function marketTypeFromJSON(object: any): MarketType {
  switch (object) {
    case 0:
    case "SPOT":
      return MarketType.SPOT;
    case 1:
    case "PERPETUALS":
      return MarketType.PERPETUALS;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MarketType");
  }
}

export function marketTypeToJSON(object: MarketType): string {
  switch (object) {
    case MarketType.SPOT:
      return "SPOT";
    case MarketType.PERPETUALS:
      return "PERPETUALS";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum MarketType");
  }
}

/**
 * Error codes returned by the engine.
 * Some errors has 5bit prefix about error source and 3 bit suffix specifier.
 * Error source prefix indicates were too look into to fix error.
 * For example if order has bad input, it would be order relevant prefix.
 * But if order cannot apply results to balance, it would be balance relevant
 * prefix.
 */
export enum Error {
  DUPLICATE = 0,
  DECODE_FAILURE = 2,
  INVALID_SIGNATURE = 3,
  MARKET_NOT_FOUND = 4,
  TOKEN_NOT_FOUND = 5,
  USER_NOT_FOUND = 6,
  SESSION_NOT_FOUND = 7,
  ORDER_NOT_FOUND = 8,
  ORDER_SIZE_ZERO = 9,
  ARITHMETIC_OVERFLOW = 11,
  RISK_TOO_HIGH = 12,
  INVALID_ORDER_OWNER = 14,
  KEY_ALREADY_REGISTERED = 15,
  EXPIRY_TIMESTAMP_IN_PAST = 16,
  UPDATE_TIMESTAMP_IN_PAST = 17,
  TOO_MANY_OPEN_ORDERS = 18,
  INVALID_ACTION_NONCE = 20,
  WITHDRAW_AMOUNT_TOO_SMALL = 21,
  PYTH_FEED_NOT_ADDED = 93,
  PYTH_FEED_MISSING = 94,
  PYTH_FEED_ALREADY_ADDED = 95,
  PYTH_GUARDIAN_SET_UNINITIALIZED = 96,
  PYTH_GUARDIAN_SET_INVALID = 97,
  PYTH_FEED_DECIMALS_OUT_OF_RANGE = 98,
  PYTH_FEED_PRICE_OUT_OF_RANGE = 99,
  PYTH_FEED_VARIANCE_OUT_OF_RANGE = 100,
  PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH = 126,
  INVALID_TOKEN_PARAMETERS = 101,
  INDEX_PRICE_OUT_OF_RANGE = 103,
  INDEX_DECIMALS_OUT_OF_RANGE = 104,
  INVALID_STATE_VERSION = 105,
  INVALID_MARGINS = 107,
  /** ACTION_CANNOT_BE_DELEGATED - means that user cannot execute proposed action on behalf of different user */
  ACTION_CANNOT_BE_DELEGATED = 108,
  /**
   * MARKET_DECIMALS_EXCEED_LIMITS - Market's decimal parameters exceed either "quote limit" or "base limit"
   * Two mentioned limits were deduced empirically and ensure
   * that certain overflow errors don't happen when value rescaling is performed
   * during order placement.
   *
   * For both perpetuals and spot markets,
   * `quote_token.decimals - market.size_decimals - market.price_decimals` must
   * be within range `[-19; 4]` For spot market, `base_token.decimals -
   * market.size_decimals` must be within range `[-19; 23]`
   */
  MARKET_DECIMALS_EXCEED_LIMITS = 109,
  TOO_MANY_TOKENS = 110,
  FUNDING_OVERFLOW = 123,
  /**
   * CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED - If there is order to cancel for position, it should be canceled first
   * before reducing position
   */
  CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED = 124,
  /** UNEXPECTED_TOKEN_ID - Token was found, but not expected to be used in action context */
  UNEXPECTED_TOKEN_ID = 127,
  /**
   * TOKEN_NOT_READY - happens in some situation when token misses some relevant information
   * needed for operation, for example index price
   */
  TOKEN_NOT_READY = 130,
  /** TOKEN_ALREADY_REGISTERED - Token with specified blockchain address already registered */
  TOKEN_ALREADY_REGISTERED = 112,
  OMF_LESS_THAN_OR_EQUAL_IMF = 131,
  ORDER_ON_UNHEALTHY_ACCOUNT_CAN_ONLY_IMPROVE = 132,
  IMMEDIATE_ORDER_GOT_NO_FILLS = 133,
  /** FAILED_TO_FILL_LIMIT - In case there's no price, error if failed to fill at least one of limits */
  FAILED_TO_FILL_LIMIT = 134,
  POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS = 135,
  INVALID = 136,
  MAINTENANCE = 137,
  MINIMUM_SIZE_DECIMALS = 138,
  PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET = 139,
  ONLY_IMMEDIATE_ORDERS_ALLOWED = 140,
  TOO_MANY_USER_ACCOUNTS = 141,
  /** ACCOUNT_NOT_FOUND - There's no such account with specified id, */
  ACCOUNT_NOT_FOUND = 142,
  /** ACCOUNT_INVALID_OWNER - Account doesn't belong to user designated by public key or session id */
  ACCOUNT_INVALID_OWNER = 143,
  /**
   * DUST_ACCOUNT - Operation cannot be made on account because to small amount will be
   * retained on account
   */
  DUST_ACCOUNT = 145,
  /** BALANCE - 10100_000 */
  BALANCE = 160,
  /** BALANCE_DEPOSIT_OVERFLOW - 10100_001 */
  BALANCE_DEPOSIT_OVERFLOW = 161,
  /** BALANCE_CHANGE_OVERFLOW - 10100_010 */
  BALANCE_CHANGE_OVERFLOW = 162,
  /** BALANCE_CHANGE_LIMIT_EXCEEDED - 10100_011 */
  BALANCE_CHANGE_LIMIT_EXCEEDED = 163,
  /**
   * BALANCE_INSUFFICIENT - Happens when account balances has no sufficient token amount to perform
   * action.
   * 10100_100
   */
  BALANCE_INSUFFICIENT = 164,
  /**
   * UNAUTHENTICATED_L1_ACTION - Happens when an action is meant to come from the settlement contract,
   * but is not authenticated, instead coming from the user channels.
   */
  UNAUTHENTICATED_L1_ACTION = 165,
  /**
   * ENCODED_ACTION_TOO_LARGE - Happens when an encoded action is too large. This is to mitigate dos
   * attacks due to excessive padding.
   */
  ENCODED_ACTION_TOO_LARGE = 166,
  /** TRIGGER - 10101_000 */
  TRIGGER = 168,
  /**
   * TRIGGER_INVALID_PRICE - Happens when:
   * * Trigger price is "less or equal" to its corresponding pair trigger price
   * * Trigger rice is "less" than market's current index price
   *
   * Binary pattern: 10101_001
   */
  TRIGGER_INVALID_PRICE = 169,
  TRIGGER_NOT_FOUND = 170,
  /** TIMESTAMP - 10110_000 */
  TIMESTAMP = 176,
  /** TIMESTAMP_OUT_OF_THRESHOLD - 10110_001 */
  TIMESTAMP_OUT_OF_THRESHOLD = 177,
  TIMESTAMP_STALE = 178,
  /** BANKRUPTCY - 10111_000 */
  BANKRUPTCY = 184,
  /** BANKRUPTCY_INSUFFICIENT_COVERAGE - 10111_001 */
  BANKRUPTCY_INSUFFICIENT_COVERAGE = 185,
  /**
   * BANKRUPTCY_NOT_FOUND - 10111_010
   * Account is not in bankruptcy state.
   */
  BANKRUPTCY_NOT_FOUND = 186,
  /**
   * MARKET_NOT_READY - 11000_000
   * Happens when market is not read to handle orders
   */
  MARKET_NOT_READY = 192,
  MARKET_FROZEN = 193,
  /** POSITION - 11001_000 */
  POSITION = 200,
  /** POSITION_NOT_FOUND - Position not found for specific entity in specific market */
  POSITION_NOT_FOUND = 201,
  POSITION_STATE_ORDER = 202,
  POSITION_STATE_ORDER_PRICE = 203,
  POSITION_STATE_ORDER_SIZE = 204,
  POSITION_STATE_ORDER_SIDE = 205,
  POSITION_SIZE_LIMIT = 206,
  PRICE = 209,
  SIGNATURE_VERIFICATION = 217,
  SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY = 218,
  SIGNATURE_VERIFICATION_INVALID_LENGTH = 219,
  /** ORDER_EXECUTION - 1111_0000 = 240 -- 4 bit suffix */
  ORDER_EXECUTION = 240,
  ORDER_EXECUTION_EMPTY = 241,
  ORDER_EXECUTION_FILL_OR_KILL = 242,
  /** ORDER_EXECUTION_MISSING_LIMITS - Order requires some of its limits specified according to fill mode */
  ORDER_EXECUTION_MISSING_LIMITS = 243,
  ORDER_EXECUTION_MISSING_PRICE = 244,
  ORDER_EXECUTION_SIZE_LIMIT = 245,
  ORDER_EXECUTION_LIMIT_PRICE = 246,
  /** ORDER_REDUCE_IS_POST_ONLY - Reduce orders can only be post only. */
  ORDER_REDUCE_IS_POST_ONLY = 247,
  /** ORDER_EXECUTION_SELL_PRICE - Order was rejected, because it planned under proposed price */
  ORDER_EXECUTION_SELL_PRICE = 248,
  NOT_IMPLEMENTED = 500,
  Dropped = 999,
}

export function errorFromJSON(object: any): Error {
  switch (object) {
    case 0:
    case "DUPLICATE":
      return Error.DUPLICATE;
    case 2:
    case "DECODE_FAILURE":
      return Error.DECODE_FAILURE;
    case 3:
    case "INVALID_SIGNATURE":
      return Error.INVALID_SIGNATURE;
    case 4:
    case "MARKET_NOT_FOUND":
      return Error.MARKET_NOT_FOUND;
    case 5:
    case "TOKEN_NOT_FOUND":
      return Error.TOKEN_NOT_FOUND;
    case 6:
    case "USER_NOT_FOUND":
      return Error.USER_NOT_FOUND;
    case 7:
    case "SESSION_NOT_FOUND":
      return Error.SESSION_NOT_FOUND;
    case 8:
    case "ORDER_NOT_FOUND":
      return Error.ORDER_NOT_FOUND;
    case 9:
    case "ORDER_SIZE_ZERO":
      return Error.ORDER_SIZE_ZERO;
    case 11:
    case "ARITHMETIC_OVERFLOW":
      return Error.ARITHMETIC_OVERFLOW;
    case 12:
    case "RISK_TOO_HIGH":
      return Error.RISK_TOO_HIGH;
    case 14:
    case "INVALID_ORDER_OWNER":
      return Error.INVALID_ORDER_OWNER;
    case 15:
    case "KEY_ALREADY_REGISTERED":
      return Error.KEY_ALREADY_REGISTERED;
    case 16:
    case "EXPIRY_TIMESTAMP_IN_PAST":
      return Error.EXPIRY_TIMESTAMP_IN_PAST;
    case 17:
    case "UPDATE_TIMESTAMP_IN_PAST":
      return Error.UPDATE_TIMESTAMP_IN_PAST;
    case 18:
    case "TOO_MANY_OPEN_ORDERS":
      return Error.TOO_MANY_OPEN_ORDERS;
    case 20:
    case "INVALID_ACTION_NONCE":
      return Error.INVALID_ACTION_NONCE;
    case 21:
    case "WITHDRAW_AMOUNT_TOO_SMALL":
      return Error.WITHDRAW_AMOUNT_TOO_SMALL;
    case 93:
    case "PYTH_FEED_NOT_ADDED":
      return Error.PYTH_FEED_NOT_ADDED;
    case 94:
    case "PYTH_FEED_MISSING":
      return Error.PYTH_FEED_MISSING;
    case 95:
    case "PYTH_FEED_ALREADY_ADDED":
      return Error.PYTH_FEED_ALREADY_ADDED;
    case 96:
    case "PYTH_GUARDIAN_SET_UNINITIALIZED":
      return Error.PYTH_GUARDIAN_SET_UNINITIALIZED;
    case 97:
    case "PYTH_GUARDIAN_SET_INVALID":
      return Error.PYTH_GUARDIAN_SET_INVALID;
    case 98:
    case "PYTH_FEED_DECIMALS_OUT_OF_RANGE":
      return Error.PYTH_FEED_DECIMALS_OUT_OF_RANGE;
    case 99:
    case "PYTH_FEED_PRICE_OUT_OF_RANGE":
      return Error.PYTH_FEED_PRICE_OUT_OF_RANGE;
    case 100:
    case "PYTH_FEED_VARIANCE_OUT_OF_RANGE":
      return Error.PYTH_FEED_VARIANCE_OUT_OF_RANGE;
    case 126:
    case "PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH":
      return Error.PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH;
    case 101:
    case "INVALID_TOKEN_PARAMETERS":
      return Error.INVALID_TOKEN_PARAMETERS;
    case 103:
    case "INDEX_PRICE_OUT_OF_RANGE":
      return Error.INDEX_PRICE_OUT_OF_RANGE;
    case 104:
    case "INDEX_DECIMALS_OUT_OF_RANGE":
      return Error.INDEX_DECIMALS_OUT_OF_RANGE;
    case 105:
    case "INVALID_STATE_VERSION":
      return Error.INVALID_STATE_VERSION;
    case 107:
    case "INVALID_MARGINS":
      return Error.INVALID_MARGINS;
    case 108:
    case "ACTION_CANNOT_BE_DELEGATED":
      return Error.ACTION_CANNOT_BE_DELEGATED;
    case 109:
    case "MARKET_DECIMALS_EXCEED_LIMITS":
      return Error.MARKET_DECIMALS_EXCEED_LIMITS;
    case 110:
    case "TOO_MANY_TOKENS":
      return Error.TOO_MANY_TOKENS;
    case 123:
    case "FUNDING_OVERFLOW":
      return Error.FUNDING_OVERFLOW;
    case 124:
    case "CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED":
      return Error.CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED;
    case 127:
    case "UNEXPECTED_TOKEN_ID":
      return Error.UNEXPECTED_TOKEN_ID;
    case 130:
    case "TOKEN_NOT_READY":
      return Error.TOKEN_NOT_READY;
    case 112:
    case "TOKEN_ALREADY_REGISTERED":
      return Error.TOKEN_ALREADY_REGISTERED;
    case 131:
    case "OMF_LESS_THAN_OR_EQUAL_IMF":
      return Error.OMF_LESS_THAN_OR_EQUAL_IMF;
    case 132:
    case "ORDER_ON_UNHEALTHY_ACCOUNT_CAN_ONLY_IMPROVE":
      return Error.ORDER_ON_UNHEALTHY_ACCOUNT_CAN_ONLY_IMPROVE;
    case 133:
    case "IMMEDIATE_ORDER_GOT_NO_FILLS":
      return Error.IMMEDIATE_ORDER_GOT_NO_FILLS;
    case 134:
    case "FAILED_TO_FILL_LIMIT":
      return Error.FAILED_TO_FILL_LIMIT;
    case 135:
    case "POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS":
      return Error.POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS;
    case 136:
    case "INVALID":
      return Error.INVALID;
    case 137:
    case "MAINTENANCE":
      return Error.MAINTENANCE;
    case 138:
    case "MINIMUM_SIZE_DECIMALS":
      return Error.MINIMUM_SIZE_DECIMALS;
    case 139:
    case "PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET":
      return Error.PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET;
    case 140:
    case "ONLY_IMMEDIATE_ORDERS_ALLOWED":
      return Error.ONLY_IMMEDIATE_ORDERS_ALLOWED;
    case 141:
    case "TOO_MANY_USER_ACCOUNTS":
      return Error.TOO_MANY_USER_ACCOUNTS;
    case 142:
    case "ACCOUNT_NOT_FOUND":
      return Error.ACCOUNT_NOT_FOUND;
    case 143:
    case "ACCOUNT_INVALID_OWNER":
      return Error.ACCOUNT_INVALID_OWNER;
    case 145:
    case "DUST_ACCOUNT":
      return Error.DUST_ACCOUNT;
    case 160:
    case "BALANCE":
      return Error.BALANCE;
    case 161:
    case "BALANCE_DEPOSIT_OVERFLOW":
      return Error.BALANCE_DEPOSIT_OVERFLOW;
    case 162:
    case "BALANCE_CHANGE_OVERFLOW":
      return Error.BALANCE_CHANGE_OVERFLOW;
    case 163:
    case "BALANCE_CHANGE_LIMIT_EXCEEDED":
      return Error.BALANCE_CHANGE_LIMIT_EXCEEDED;
    case 164:
    case "BALANCE_INSUFFICIENT":
      return Error.BALANCE_INSUFFICIENT;
    case 165:
    case "UNAUTHENTICATED_L1_ACTION":
      return Error.UNAUTHENTICATED_L1_ACTION;
    case 166:
    case "ENCODED_ACTION_TOO_LARGE":
      return Error.ENCODED_ACTION_TOO_LARGE;
    case 168:
    case "TRIGGER":
      return Error.TRIGGER;
    case 169:
    case "TRIGGER_INVALID_PRICE":
      return Error.TRIGGER_INVALID_PRICE;
    case 170:
    case "TRIGGER_NOT_FOUND":
      return Error.TRIGGER_NOT_FOUND;
    case 176:
    case "TIMESTAMP":
      return Error.TIMESTAMP;
    case 177:
    case "TIMESTAMP_OUT_OF_THRESHOLD":
      return Error.TIMESTAMP_OUT_OF_THRESHOLD;
    case 178:
    case "TIMESTAMP_STALE":
      return Error.TIMESTAMP_STALE;
    case 184:
    case "BANKRUPTCY":
      return Error.BANKRUPTCY;
    case 185:
    case "BANKRUPTCY_INSUFFICIENT_COVERAGE":
      return Error.BANKRUPTCY_INSUFFICIENT_COVERAGE;
    case 186:
    case "BANKRUPTCY_NOT_FOUND":
      return Error.BANKRUPTCY_NOT_FOUND;
    case 192:
    case "MARKET_NOT_READY":
      return Error.MARKET_NOT_READY;
    case 193:
    case "MARKET_FROZEN":
      return Error.MARKET_FROZEN;
    case 200:
    case "POSITION":
      return Error.POSITION;
    case 201:
    case "POSITION_NOT_FOUND":
      return Error.POSITION_NOT_FOUND;
    case 202:
    case "POSITION_STATE_ORDER":
      return Error.POSITION_STATE_ORDER;
    case 203:
    case "POSITION_STATE_ORDER_PRICE":
      return Error.POSITION_STATE_ORDER_PRICE;
    case 204:
    case "POSITION_STATE_ORDER_SIZE":
      return Error.POSITION_STATE_ORDER_SIZE;
    case 205:
    case "POSITION_STATE_ORDER_SIDE":
      return Error.POSITION_STATE_ORDER_SIDE;
    case 206:
    case "POSITION_SIZE_LIMIT":
      return Error.POSITION_SIZE_LIMIT;
    case 209:
    case "PRICE":
      return Error.PRICE;
    case 217:
    case "SIGNATURE_VERIFICATION":
      return Error.SIGNATURE_VERIFICATION;
    case 218:
    case "SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY":
      return Error.SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY;
    case 219:
    case "SIGNATURE_VERIFICATION_INVALID_LENGTH":
      return Error.SIGNATURE_VERIFICATION_INVALID_LENGTH;
    case 240:
    case "ORDER_EXECUTION":
      return Error.ORDER_EXECUTION;
    case 241:
    case "ORDER_EXECUTION_EMPTY":
      return Error.ORDER_EXECUTION_EMPTY;
    case 242:
    case "ORDER_EXECUTION_FILL_OR_KILL":
      return Error.ORDER_EXECUTION_FILL_OR_KILL;
    case 243:
    case "ORDER_EXECUTION_MISSING_LIMITS":
      return Error.ORDER_EXECUTION_MISSING_LIMITS;
    case 244:
    case "ORDER_EXECUTION_MISSING_PRICE":
      return Error.ORDER_EXECUTION_MISSING_PRICE;
    case 245:
    case "ORDER_EXECUTION_SIZE_LIMIT":
      return Error.ORDER_EXECUTION_SIZE_LIMIT;
    case 246:
    case "ORDER_EXECUTION_LIMIT_PRICE":
      return Error.ORDER_EXECUTION_LIMIT_PRICE;
    case 247:
    case "ORDER_REDUCE_IS_POST_ONLY":
      return Error.ORDER_REDUCE_IS_POST_ONLY;
    case 248:
    case "ORDER_EXECUTION_SELL_PRICE":
      return Error.ORDER_EXECUTION_SELL_PRICE;
    case 500:
    case "NOT_IMPLEMENTED":
      return Error.NOT_IMPLEMENTED;
    case 999:
    case "Dropped":
      return Error.Dropped;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Error");
  }
}

export function errorToJSON(object: Error): string {
  switch (object) {
    case Error.DUPLICATE:
      return "DUPLICATE";
    case Error.DECODE_FAILURE:
      return "DECODE_FAILURE";
    case Error.INVALID_SIGNATURE:
      return "INVALID_SIGNATURE";
    case Error.MARKET_NOT_FOUND:
      return "MARKET_NOT_FOUND";
    case Error.TOKEN_NOT_FOUND:
      return "TOKEN_NOT_FOUND";
    case Error.USER_NOT_FOUND:
      return "USER_NOT_FOUND";
    case Error.SESSION_NOT_FOUND:
      return "SESSION_NOT_FOUND";
    case Error.ORDER_NOT_FOUND:
      return "ORDER_NOT_FOUND";
    case Error.ORDER_SIZE_ZERO:
      return "ORDER_SIZE_ZERO";
    case Error.ARITHMETIC_OVERFLOW:
      return "ARITHMETIC_OVERFLOW";
    case Error.RISK_TOO_HIGH:
      return "RISK_TOO_HIGH";
    case Error.INVALID_ORDER_OWNER:
      return "INVALID_ORDER_OWNER";
    case Error.KEY_ALREADY_REGISTERED:
      return "KEY_ALREADY_REGISTERED";
    case Error.EXPIRY_TIMESTAMP_IN_PAST:
      return "EXPIRY_TIMESTAMP_IN_PAST";
    case Error.UPDATE_TIMESTAMP_IN_PAST:
      return "UPDATE_TIMESTAMP_IN_PAST";
    case Error.TOO_MANY_OPEN_ORDERS:
      return "TOO_MANY_OPEN_ORDERS";
    case Error.INVALID_ACTION_NONCE:
      return "INVALID_ACTION_NONCE";
    case Error.WITHDRAW_AMOUNT_TOO_SMALL:
      return "WITHDRAW_AMOUNT_TOO_SMALL";
    case Error.PYTH_FEED_NOT_ADDED:
      return "PYTH_FEED_NOT_ADDED";
    case Error.PYTH_FEED_MISSING:
      return "PYTH_FEED_MISSING";
    case Error.PYTH_FEED_ALREADY_ADDED:
      return "PYTH_FEED_ALREADY_ADDED";
    case Error.PYTH_GUARDIAN_SET_UNINITIALIZED:
      return "PYTH_GUARDIAN_SET_UNINITIALIZED";
    case Error.PYTH_GUARDIAN_SET_INVALID:
      return "PYTH_GUARDIAN_SET_INVALID";
    case Error.PYTH_FEED_DECIMALS_OUT_OF_RANGE:
      return "PYTH_FEED_DECIMALS_OUT_OF_RANGE";
    case Error.PYTH_FEED_PRICE_OUT_OF_RANGE:
      return "PYTH_FEED_PRICE_OUT_OF_RANGE";
    case Error.PYTH_FEED_VARIANCE_OUT_OF_RANGE:
      return "PYTH_FEED_VARIANCE_OUT_OF_RANGE";
    case Error.PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH:
      return "PYTH_GUARDIAN_SET_AND_PYTH_SIGNATURE_DO_NOT_MATCH";
    case Error.INVALID_TOKEN_PARAMETERS:
      return "INVALID_TOKEN_PARAMETERS";
    case Error.INDEX_PRICE_OUT_OF_RANGE:
      return "INDEX_PRICE_OUT_OF_RANGE";
    case Error.INDEX_DECIMALS_OUT_OF_RANGE:
      return "INDEX_DECIMALS_OUT_OF_RANGE";
    case Error.INVALID_STATE_VERSION:
      return "INVALID_STATE_VERSION";
    case Error.INVALID_MARGINS:
      return "INVALID_MARGINS";
    case Error.ACTION_CANNOT_BE_DELEGATED:
      return "ACTION_CANNOT_BE_DELEGATED";
    case Error.MARKET_DECIMALS_EXCEED_LIMITS:
      return "MARKET_DECIMALS_EXCEED_LIMITS";
    case Error.TOO_MANY_TOKENS:
      return "TOO_MANY_TOKENS";
    case Error.FUNDING_OVERFLOW:
      return "FUNDING_OVERFLOW";
    case Error.CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED:
      return "CAN_REDUCE_POSITION_ONLY_IF_ALL_ORDERS_ARE_CANCELED";
    case Error.UNEXPECTED_TOKEN_ID:
      return "UNEXPECTED_TOKEN_ID";
    case Error.TOKEN_NOT_READY:
      return "TOKEN_NOT_READY";
    case Error.TOKEN_ALREADY_REGISTERED:
      return "TOKEN_ALREADY_REGISTERED";
    case Error.OMF_LESS_THAN_OR_EQUAL_IMF:
      return "OMF_LESS_THAN_OR_EQUAL_IMF";
    case Error.ORDER_ON_UNHEALTHY_ACCOUNT_CAN_ONLY_IMPROVE:
      return "ORDER_ON_UNHEALTHY_ACCOUNT_CAN_ONLY_IMPROVE";
    case Error.IMMEDIATE_ORDER_GOT_NO_FILLS:
      return "IMMEDIATE_ORDER_GOT_NO_FILLS";
    case Error.FAILED_TO_FILL_LIMIT:
      return "FAILED_TO_FILL_LIMIT";
    case Error.POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS:
      return "POST_ONLY_MUST_NOT_FILL_ANY_OPPOSITE_ORDERS";
    case Error.INVALID:
      return "INVALID";
    case Error.MAINTENANCE:
      return "MAINTENANCE";
    case Error.MINIMUM_SIZE_DECIMALS:
      return "MINIMUM_SIZE_DECIMALS";
    case Error.PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET:
      return "PARAMETERS_WILL_CREATE_NON_OPERATIONAL_MARKET";
    case Error.ONLY_IMMEDIATE_ORDERS_ALLOWED:
      return "ONLY_IMMEDIATE_ORDERS_ALLOWED";
    case Error.TOO_MANY_USER_ACCOUNTS:
      return "TOO_MANY_USER_ACCOUNTS";
    case Error.ACCOUNT_NOT_FOUND:
      return "ACCOUNT_NOT_FOUND";
    case Error.ACCOUNT_INVALID_OWNER:
      return "ACCOUNT_INVALID_OWNER";
    case Error.DUST_ACCOUNT:
      return "DUST_ACCOUNT";
    case Error.BALANCE:
      return "BALANCE";
    case Error.BALANCE_DEPOSIT_OVERFLOW:
      return "BALANCE_DEPOSIT_OVERFLOW";
    case Error.BALANCE_CHANGE_OVERFLOW:
      return "BALANCE_CHANGE_OVERFLOW";
    case Error.BALANCE_CHANGE_LIMIT_EXCEEDED:
      return "BALANCE_CHANGE_LIMIT_EXCEEDED";
    case Error.BALANCE_INSUFFICIENT:
      return "BALANCE_INSUFFICIENT";
    case Error.UNAUTHENTICATED_L1_ACTION:
      return "UNAUTHENTICATED_L1_ACTION";
    case Error.ENCODED_ACTION_TOO_LARGE:
      return "ENCODED_ACTION_TOO_LARGE";
    case Error.TRIGGER:
      return "TRIGGER";
    case Error.TRIGGER_INVALID_PRICE:
      return "TRIGGER_INVALID_PRICE";
    case Error.TRIGGER_NOT_FOUND:
      return "TRIGGER_NOT_FOUND";
    case Error.TIMESTAMP:
      return "TIMESTAMP";
    case Error.TIMESTAMP_OUT_OF_THRESHOLD:
      return "TIMESTAMP_OUT_OF_THRESHOLD";
    case Error.TIMESTAMP_STALE:
      return "TIMESTAMP_STALE";
    case Error.BANKRUPTCY:
      return "BANKRUPTCY";
    case Error.BANKRUPTCY_INSUFFICIENT_COVERAGE:
      return "BANKRUPTCY_INSUFFICIENT_COVERAGE";
    case Error.BANKRUPTCY_NOT_FOUND:
      return "BANKRUPTCY_NOT_FOUND";
    case Error.MARKET_NOT_READY:
      return "MARKET_NOT_READY";
    case Error.MARKET_FROZEN:
      return "MARKET_FROZEN";
    case Error.POSITION:
      return "POSITION";
    case Error.POSITION_NOT_FOUND:
      return "POSITION_NOT_FOUND";
    case Error.POSITION_STATE_ORDER:
      return "POSITION_STATE_ORDER";
    case Error.POSITION_STATE_ORDER_PRICE:
      return "POSITION_STATE_ORDER_PRICE";
    case Error.POSITION_STATE_ORDER_SIZE:
      return "POSITION_STATE_ORDER_SIZE";
    case Error.POSITION_STATE_ORDER_SIDE:
      return "POSITION_STATE_ORDER_SIDE";
    case Error.POSITION_SIZE_LIMIT:
      return "POSITION_SIZE_LIMIT";
    case Error.PRICE:
      return "PRICE";
    case Error.SIGNATURE_VERIFICATION:
      return "SIGNATURE_VERIFICATION";
    case Error.SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY:
      return "SIGNATURE_VERIFICATION_MALFORMED_PUBLIC_KEY";
    case Error.SIGNATURE_VERIFICATION_INVALID_LENGTH:
      return "SIGNATURE_VERIFICATION_INVALID_LENGTH";
    case Error.ORDER_EXECUTION:
      return "ORDER_EXECUTION";
    case Error.ORDER_EXECUTION_EMPTY:
      return "ORDER_EXECUTION_EMPTY";
    case Error.ORDER_EXECUTION_FILL_OR_KILL:
      return "ORDER_EXECUTION_FILL_OR_KILL";
    case Error.ORDER_EXECUTION_MISSING_LIMITS:
      return "ORDER_EXECUTION_MISSING_LIMITS";
    case Error.ORDER_EXECUTION_MISSING_PRICE:
      return "ORDER_EXECUTION_MISSING_PRICE";
    case Error.ORDER_EXECUTION_SIZE_LIMIT:
      return "ORDER_EXECUTION_SIZE_LIMIT";
    case Error.ORDER_EXECUTION_LIMIT_PRICE:
      return "ORDER_EXECUTION_LIMIT_PRICE";
    case Error.ORDER_REDUCE_IS_POST_ONLY:
      return "ORDER_REDUCE_IS_POST_ONLY";
    case Error.ORDER_EXECUTION_SELL_PRICE:
      return "ORDER_EXECUTION_SELL_PRICE";
    case Error.NOT_IMPLEMENTED:
      return "NOT_IMPLEMENTED";
    case Error.Dropped:
      return "Dropped";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum Error");
  }
}

export enum SpecialAccount {
  FeeVault = 0,
}

export function specialAccountFromJSON(object: any): SpecialAccount {
  switch (object) {
    case 0:
    case "FeeVault":
      return SpecialAccount.FeeVault;
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SpecialAccount");
  }
}

export function specialAccountToJSON(object: SpecialAccount): string {
  switch (object) {
    case SpecialAccount.FeeVault:
      return "FeeVault";
    default:
      throw new globalThis.Error("Unrecognized enum value " + object + " for enum SpecialAccount");
  }
}

/** Emulation of 128-bit integers since Protobuf doesn't have native support */
export interface U128 {
  /** Low 64-bit word */
  lo: bigint;
  /** High 64-bit word */
  hi: bigint;
}

export interface Market {
  marketId: number;
  priceDecimals: number;
  sizeDecimals: number;
  baseTokenId: number;
  marketType: MarketType;
  imfBps: number;
  cmfBps: number;
  mmfBps: number;
  viewSymbol: string;
}

export interface Token {
  tokenId: number;
  /** / See CreateToken for details. */
  tokenDecimals: number;
  weightBps: number;
  viewSymbol: string;
}

export interface Action {
  /**
   * Must be within 60s of the engine's current logical time, which
   * should be within a few seconds of real time.
   *
   * Ignored for the `PythPriceFeedUpdate` action as that action updates
   * the timestamp. Should be set to 0 in that case to omit it.
   */
  currentTimestamp: bigint;
  /**
   * Optional nonce to handle if user wants several identical transactions to be
   * executed with `current_timestamp`. Sending exactly same transaction twice
   * is rejected. In order to change signature of transaction(execute it once
   * more time), nonce should be changed(incremented).
   */
  nonce: number;
  kind?:
    | { $case: "createSession"; value: Action_CreateSession }
    | { $case: "createToken"; value: Action_CreateToken }
    | { $case: "createMarket"; value: Action_CreateMarket }
    | { $case: "placeOrder"; value: Action_PlaceOrder }
    | { $case: "cancelOrderById"; value: Action_CancelOrderById }
    | { $case: "deposit"; value: Action_Deposit }
    | { $case: "withdraw"; value: Action_Withdraw }
    | { $case: "pythSetWormholeGuardians"; value: Action_PythSetWormholeGuardians }
    | { $case: "pythSetSymbolFeed"; value: Action_PythSetSymbolFeed }
    | { $case: "pythPriceFeedUpdate"; value: Action_PythPriceFeedUpdate }
    | { $case: "liquidate"; value: Action_Liquidate }
    | { $case: "revokeSession"; value: Action_RevokeSession }
    | { $case: "pause"; value: Action_Pause }
    | { $case: "unpause"; value: Action_Unpause }
    | { $case: "transfer"; value: Action_Transfer }
    | { $case: "message"; value: Message }
    | { $case: "addTrigger"; value: Action_AddTrigger }
    | { $case: "removeTrigger"; value: Action_RemoveTrigger }
    | { $case: "takePosition"; value: Action_TakePosition }
    | undefined;
}

export interface Action_CreateSession {
  /**
   * User's SECP256K1 registration public key, 33 bytes long;
   * user must be previously registered with that key
   */
  userPubkey: Uint8Array;
  /** MUST be 32 bytes. */
  blstPubkey: Uint8Array;
  expiryTimestamp: bigint;
}

export interface Action_CreateToken {
  /**
   * / Example:
   * / Settlement 1 ETH is 10**18 value.
   * / With `token_decimals` of `10`, engine balance will have 1 ETH = 10**10
   * / value. Rollup sends to engine and expects from engine 10**10 as 1 ETH
   * / value. So if user has on balance 10**9 of ETH, it means he has 0.1 ETH
   * / on engine balance and in settlement, but in settlement it will be
   * / represented as 10**17 value. As consequence, if oracle gives index_price
   * / of 1 ETH as it is in Ethereum, we must divide balance by
   * / `10**token_decimals` and multiply by price to get USD value (do not
   * / forget allow for rounding sub USD values). As for market price, to trade
   * / 0.1 ETH,
   * need to 1/10 / 10**token_decimals * 10**Market.size_decimals
   */
  tokenDecimals: number;
  weightBps: number;
  viewSymbol: string;
  /** / Used to bind to relevant oracle feed */
  oracleSymbol: string;
  /** On chain id for the wrapped asset on the rollup */
  solAddr: Uint8Array;
}

export interface Action_CreateMarket {
  sizeDecimals: number;
  priceDecimals: number;
  imfBps: number;
  cmfBps: number;
  mmfBps: number;
  marketType: MarketType;
  /**
   * Arbitrary human-readable market symbol, not to be confused with token's
   * symbol
   */
  viewSymbol: string;
  /**
   * Oracle symbol which references specific price feed. Must be
   * `oracle_symbol` of registered price feed
   */
  oracleSymbol: string;
  /**
   * One of registered `token_id`'s.
   *
   * Base token for `MarketType::Spot`.
   *
   * Same as quote token id for `MarketType::Perpetual`. `oracle_symbol`
   * identifies relevant price feed.
   */
  baseTokenId: number;
}

/**
 * Note on order size.
 * Any order being placed has absolute maximum size, which is 2^48-1.
 * Although, this limit is applied not to initial order being placed
 * but to final order being added to market's orderbook.
 * This behavior exists because order can be limited by quote size,
 * which converts to order size in a non-linear manner.
 *
 * Some orders can be executed immediately, in this no order will be added to
 * orderbook, no order id created. Consider using `client_order_id` to track
 * execution of such orders.
 *
 * Example: User posts order with size 2^48+100_000. Order fills counter
 * orders and its size is reduced to 2^48-1_000_000 in process. This order
 * will be added to orderbook successfully despite its initial size is above
 * limit.
 */
export interface Action_PlaceOrder {
  sessionId: bigint;
  marketId: number;
  side: Side;
  fillMode: FillMode;
  /**
   * A reduce-only order only reduces your current position, as opposed to
   * increasing it. It means you can only use it to close a position. In
   * contrast, non-reduce-only orders can reduce or increase your position.
   * Reduce is handled by dynamically reducing or adjusting limit order's
   * contract quantity
   * / to match the contract size of the open position.
   */
  isReduceOnly: boolean;
  /**
   * Raw integral value of order limit price.
   * `1` here equals to market's `10^-price_decimals`
   * When used in token balances and reward computations, shifted by market's
   * `price_decimals`. Optional, treated as not set if 0.
   */
  price: bigint;
  /**
   * Raw integral value of order size limit.
   * For spot markers measured in base size,
   * for perpetuals in contract token.
   * So using base as default naming in codebase.
   * `1` here equals to market's `10^-size_decimals`
   * When used in token balances and reward computations, shifted by market's
   * `size_decimals`. Optional, treated as not set if 0.
   */
  size: bigint;
  /**
   * Raw integral value of order quote size limit.
   * `1` here equals to market's `10^-(size_decimals + price_decimals)`
   * When used in token balances and reward computations, shifted by market's
   * `size_decimals + price_decimals`. Optional, treated as not set if 0.
   *
   * NB: Requires 128-bit value because it can be seen as sum
   * of order sizes multiplied by respective prices. Since size is up to 48
   * bits and price is up to 64 bits, their product can easily exceed 64 bits.
   */
  quoteSize:
    | U128
    | undefined;
  /**
   * Optional account on behalf of whom the order should be placed.
   * Executed only if sender has delegated authority to do so,
   * like admin user or liquidator bot.
   * # Delegation allowed if:
   * - trigger
   * - reduce bad position
   * - sell at good price to reduce if cannot cover bad position
   */
  delegatorAccountId?:
    | number
    | undefined;
  /**
   * Caller provided opaque order identifier up to 8 bytes.
   * Not used by engine, but can be used by client to track orders.
   */
  clientOrderId?:
    | bigint
    | undefined;
  /**
   * Account id which performs operation;
   * if not specified, first account of session's owner user is picked
   */
  senderAccountId?: number | undefined;
}

export interface Action_CancelOrderById {
  sessionId: bigint;
  orderId: bigint;
  delegatorAccountId?: number | undefined;
  senderAccountId?: number | undefined;
}

export interface Action_Deposit {
  /** used for integration of rollup with nord app */
  actionNonce: bigint;
  tokenAddr: Uint8Array;
  /** Shifted by the token's decimals. */
  amount: bigint;
  /** User's SECP256K1 registration public key, 33 bytes long */
  userPubkey: Uint8Array;
}

/** todo(n1): when gate will be here, remove or replace internals with message */
export interface Action_Withdraw {
  tokenId: number;
  sessionId: bigint;
  /** Shifted by the token's decimals. */
  amount: bigint;
}

export interface Action_PythSetWormholeGuardians {
  /**
   * See
   * https://docs.wormhole.com/wormhole/reference/api-docs/swagger#v1-guardianset-current
   */
  guardianSetIndex: number;
  /**
   * Each address is 20 bytes, consisting of the last 20 bytes
   * of the keccak256 hash of the public key of the guardian.
   */
  addresses: Uint8Array[];
}

/** Associate a oracle symbol to a Pyth Feed ID. */
export interface Action_PythSetSymbolFeed {
  oracleSymbol: string;
  /** MUST be 32 bytes. */
  priceFeedId: Uint8Array;
}

export interface Action_PythPriceFeedUpdate {
  /** See https://hermes.pyth.network/docs/#/rest/latest_price_updates */
  rawPythnetData: Uint8Array;
}

/**
 * Perform final account liquidation procedure.
 * Can be executed only accounts with AV < 0 (bankrupt).
 * After execution, `liquidatee_account_id` is removed from state.
 * See MARKETS.md `Bankruptcy` for details.
 */
export interface Action_Liquidate {
  liquidatorSessionId: bigint;
  liquidateeAccountId: number;
  liquidatorAccountId?: number | undefined;
}

export interface Action_RevokeSession {
  sessionId: bigint;
}

/** The engine fails with a maintenance error while paused. */
export interface Action_Pause {
}

export interface Action_Unpause {
}

/** Transfers tokens to specified account. */
export interface Action_Transfer {
  sessionId: bigint;
  fromAccountId: number;
  tokenId: number;
  amount: bigint;
  /** If target account id isn't specified, new account is created. */
  toAccountId?:
    | number
    | undefined;
  /**
   * If specified, than `to_account_id` must be none.
   * Transfer funds to accounts, for example to cover bankruptcies.
   */
  specialAccount?: SpecialAccount | undefined;
}

export interface Action_AddTrigger {
  sessionId: bigint;
  marketId: number;
  kind: TriggerKind;
  side: Side;
  /** Same price format as when placing order */
  price: bigint;
  accountId?: number | undefined;
}

export interface Action_RemoveTrigger {
  sessionId: bigint;
  marketId: number;
  kind: TriggerKind;
  side: Side;
  accountId?: number | undefined;
}

export interface Action_TakePosition {
  sessionId: bigint;
  marketId: number;
  /** Amount to take. */
  size: bigint;
  /**
   * Account id which performs operation;
   * if not specified, first account of session's owner user is picked
   */
  senderAccountId?:
    | number
    | undefined;
  /**
   * If set, then it is take action.
   * If price not so good as in field, take will fail.
   *
   * If not set,
   * will do fill-or-kill order as per liquidation trade rule.
   */
  price?: bigint | undefined;
}

export interface Receipt {
  /**
   * Action id which was run to produce this receipt.
   * In case of error it was next action id which did not incremented because of
   * error.
   */
  actionId: bigint;
  kind?:
    | { $case: "err"; value: Error }
    | { $case: "createSessionResult"; value: Receipt_CreateSessionResult }
    | { $case: "placeOrderResult"; value: Receipt_PlaceOrderResult }
    | { $case: "cancelOrderResult"; value: Receipt_CancelOrderResult }
    | { $case: "depositResult"; value: Receipt_DepositResult }
    | { $case: "insertTokenResult"; value: Receipt_InsertTokenResult }
    | { $case: "insertMarketResult"; value: Receipt_InsertMarketResult }
    | { $case: "withdrawResult"; value: Receipt_WithdrawResult }
    | { $case: "oracleSymbolFeedResult"; value: Receipt_OracleSymbolFeedResult }
    | { $case: "oracleUpdateResult"; value: Receipt_OracleUpdateResult }
    | { $case: "updateGuardianSetResult"; value: Receipt_UpdateGuardianSetResult }
    | { $case: "liquidated"; value: Receipt_AccountLiquidated }
    | { $case: "sessionRevoked"; value: Receipt_SessionRevoked }
    | { $case: "paused"; value: Receipt_Paused }
    | { $case: "unpaused"; value: Receipt_Unpaused }
    | { $case: "transferred"; value: Receipt_Transferred }
    | { $case: "triggerAdded"; value: Receipt_TriggerAdded }
    | { $case: "triggerRemoved"; value: Receipt_TriggerRemoved }
    | { $case: "positionTakenOrTraded"; value: Receipt_PositionTakenOrTradedResult }
    | undefined;
}

export interface Receipt_Posted {
  side: Side;
  marketId: number;
  price: bigint;
  size: bigint;
  orderId: bigint;
  accountId: number;
}

export interface Receipt_Trade {
  orderId: bigint;
  /** non zero */
  price: bigint;
  size: bigint;
  accountId: number;
}

export interface Receipt_CreateSessionResult {
  sessionId: bigint;
}

export interface Receipt_PlaceOrderResult {
  posted?: Receipt_Posted | undefined;
  fills: Receipt_Trade[];
  clientOrderId?: bigint | undefined;
}

export interface Receipt_TakenResult {
  pnl: bigint;
  size: bigint;
  takerAccountId: number;
}

export interface Receipt_PositionTakenOrTradedResult {
  marketId: number;
  PositionTakenOrTradedKind?: { $case: "taken"; value: Receipt_TakenResult } | //
  /** non empty if trade immediately */
  { $case: "traded"; value: Receipt_PlaceOrderResult } | undefined;
}

export interface Receipt_CancelOrderResult {
  orderId: bigint;
  /** Account from which order was cancelled */
  accountId: number;
}

export interface Receipt_DepositResult {
  tokenId: number;
  amount: bigint;
  /** Default account of newly created or existing user */
  accountId: number;
  userCreated: boolean;
  userPubkey: Uint8Array;
}

export interface Receipt_InsertTokenResult {
  chainAddr: Uint8Array;
  token: Token | undefined;
}

export interface Receipt_InsertMarketResult {
  market: Market | undefined;
}

export interface Receipt_WithdrawResult {
  tokenId: number;
  amount: bigint;
  balance: bigint;
  accountId: number;
  userPubkey: Uint8Array;
}

/** pyth receipts are not user facing, so they can be terse and optional */
export interface Receipt_OracleSymbolFeedResult {
  oracleSymbol: string;
  feedId: Uint8Array;
}

export interface Receipt_OracleUpdateResult {
  timestamp: bigint;
}

export interface Receipt_UpdateGuardianSetResult {
  guardianSetIndex: number;
  addresses: Uint8Array[];
}

export interface Receipt_PerpPosition {
  marketId: number;
  baseSize: bigint;
  price: bigint;
}

/** / Result of bankruptcy liquidation. */
export interface Receipt_AccountLiquidated {
  liquidatorAccountId: number;
  liquidateeAccountId: number;
  cancelledOrders: bigint[];
  removedPerps: Receipt_PerpPosition[];
}

export interface Receipt_SessionRevoked {
}

export interface Receipt_Paused {
}

export interface Receipt_Unpaused {
}

export interface Receipt_Transferred {
  fromAccountId: number;
  toUserAccount?: number | undefined;
  tokenId: number;
  amount: bigint;
  accountCreated: boolean;
  toSpecialAccount?: SpecialAccount | undefined;
}

export interface Receipt_TriggerAdded {
}

export interface Receipt_TriggerRemoved {
}

function createBaseU128(): U128 {
  return { lo: 0n, hi: 0n };
}

export const U128: MessageFns<U128> = {
  encode(message: U128, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lo !== 0n) {
      if (BigInt.asUintN(64, message.lo) !== message.lo) {
        throw new globalThis.Error("value provided for field message.lo of type uint64 too large");
      }
      writer.uint32(8).uint64(message.lo);
    }
    if (message.hi !== 0n) {
      if (BigInt.asUintN(64, message.hi) !== message.hi) {
        throw new globalThis.Error("value provided for field message.hi of type uint64 too large");
      }
      writer.uint32(16).uint64(message.hi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): U128 {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseU128();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lo = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hi = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): U128 {
    return { lo: isSet(object.lo) ? BigInt(object.lo) : 0n, hi: isSet(object.hi) ? BigInt(object.hi) : 0n };
  },

  toJSON(message: U128): unknown {
    const obj: any = {};
    if (message.lo !== 0n) {
      obj.lo = message.lo.toString();
    }
    if (message.hi !== 0n) {
      obj.hi = message.hi.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<U128>, I>>(base?: I): U128 {
    return U128.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<U128>, I>>(object: I): U128 {
    const message = createBaseU128();
    message.lo = object.lo ?? 0n;
    message.hi = object.hi ?? 0n;
    return message;
  },
};

function createBaseMarket(): Market {
  return {
    marketId: 0,
    priceDecimals: 0,
    sizeDecimals: 0,
    baseTokenId: 0,
    marketType: 0,
    imfBps: 0,
    cmfBps: 0,
    mmfBps: 0,
    viewSymbol: "",
  };
}

export const Market: MessageFns<Market> = {
  encode(message: Market, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.priceDecimals !== 0) {
      writer.uint32(16).uint32(message.priceDecimals);
    }
    if (message.sizeDecimals !== 0) {
      writer.uint32(24).uint32(message.sizeDecimals);
    }
    if (message.baseTokenId !== 0) {
      writer.uint32(32).uint32(message.baseTokenId);
    }
    if (message.marketType !== 0) {
      writer.uint32(40).int32(message.marketType);
    }
    if (message.imfBps !== 0) {
      writer.uint32(48).uint32(message.imfBps);
    }
    if (message.cmfBps !== 0) {
      writer.uint32(56).uint32(message.cmfBps);
    }
    if (message.mmfBps !== 0) {
      writer.uint32(64).uint32(message.mmfBps);
    }
    if (message.viewSymbol !== "") {
      writer.uint32(82).string(message.viewSymbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Market {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priceDecimals = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sizeDecimals = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.baseTokenId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.marketType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.imfBps = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.cmfBps = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.mmfBps = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.viewSymbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Market {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      priceDecimals: isSet(object.priceDecimals) ? globalThis.Number(object.priceDecimals) : 0,
      sizeDecimals: isSet(object.sizeDecimals) ? globalThis.Number(object.sizeDecimals) : 0,
      baseTokenId: isSet(object.baseTokenId) ? globalThis.Number(object.baseTokenId) : 0,
      marketType: isSet(object.marketType) ? marketTypeFromJSON(object.marketType) : 0,
      imfBps: isSet(object.imfBps) ? globalThis.Number(object.imfBps) : 0,
      cmfBps: isSet(object.cmfBps) ? globalThis.Number(object.cmfBps) : 0,
      mmfBps: isSet(object.mmfBps) ? globalThis.Number(object.mmfBps) : 0,
      viewSymbol: isSet(object.viewSymbol) ? globalThis.String(object.viewSymbol) : "",
    };
  },

  toJSON(message: Market): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.priceDecimals !== 0) {
      obj.priceDecimals = Math.round(message.priceDecimals);
    }
    if (message.sizeDecimals !== 0) {
      obj.sizeDecimals = Math.round(message.sizeDecimals);
    }
    if (message.baseTokenId !== 0) {
      obj.baseTokenId = Math.round(message.baseTokenId);
    }
    if (message.marketType !== 0) {
      obj.marketType = marketTypeToJSON(message.marketType);
    }
    if (message.imfBps !== 0) {
      obj.imfBps = Math.round(message.imfBps);
    }
    if (message.cmfBps !== 0) {
      obj.cmfBps = Math.round(message.cmfBps);
    }
    if (message.mmfBps !== 0) {
      obj.mmfBps = Math.round(message.mmfBps);
    }
    if (message.viewSymbol !== "") {
      obj.viewSymbol = message.viewSymbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Market>, I>>(base?: I): Market {
    return Market.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Market>, I>>(object: I): Market {
    const message = createBaseMarket();
    message.marketId = object.marketId ?? 0;
    message.priceDecimals = object.priceDecimals ?? 0;
    message.sizeDecimals = object.sizeDecimals ?? 0;
    message.baseTokenId = object.baseTokenId ?? 0;
    message.marketType = object.marketType ?? 0;
    message.imfBps = object.imfBps ?? 0;
    message.cmfBps = object.cmfBps ?? 0;
    message.mmfBps = object.mmfBps ?? 0;
    message.viewSymbol = object.viewSymbol ?? "";
    return message;
  },
};

function createBaseToken(): Token {
  return { tokenId: 0, tokenDecimals: 0, weightBps: 0, viewSymbol: "" };
}

export const Token: MessageFns<Token> = {
  encode(message: Token, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.tokenDecimals !== 0) {
      writer.uint32(16).uint32(message.tokenDecimals);
    }
    if (message.weightBps !== 0) {
      writer.uint32(32).uint32(message.weightBps);
    }
    if (message.viewSymbol !== "") {
      writer.uint32(42).string(message.viewSymbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Token {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tokenDecimals = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.weightBps = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.viewSymbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Token {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      tokenDecimals: isSet(object.tokenDecimals) ? globalThis.Number(object.tokenDecimals) : 0,
      weightBps: isSet(object.weightBps) ? globalThis.Number(object.weightBps) : 0,
      viewSymbol: isSet(object.viewSymbol) ? globalThis.String(object.viewSymbol) : "",
    };
  },

  toJSON(message: Token): unknown {
    const obj: any = {};
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.tokenDecimals !== 0) {
      obj.tokenDecimals = Math.round(message.tokenDecimals);
    }
    if (message.weightBps !== 0) {
      obj.weightBps = Math.round(message.weightBps);
    }
    if (message.viewSymbol !== "") {
      obj.viewSymbol = message.viewSymbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Token>, I>>(base?: I): Token {
    return Token.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Token>, I>>(object: I): Token {
    const message = createBaseToken();
    message.tokenId = object.tokenId ?? 0;
    message.tokenDecimals = object.tokenDecimals ?? 0;
    message.weightBps = object.weightBps ?? 0;
    message.viewSymbol = object.viewSymbol ?? "";
    return message;
  },
};

function createBaseAction(): Action {
  return { currentTimestamp: 0n, nonce: 0, kind: undefined };
}

export const Action: MessageFns<Action> = {
  encode(message: Action, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentTimestamp !== 0n) {
      if (BigInt.asIntN(64, message.currentTimestamp) !== message.currentTimestamp) {
        throw new globalThis.Error("value provided for field message.currentTimestamp of type int64 too large");
      }
      writer.uint32(8).int64(message.currentTimestamp);
    }
    if (message.nonce !== 0) {
      writer.uint32(16).uint32(message.nonce);
    }
    switch (message.kind?.$case) {
      case "createSession":
        Action_CreateSession.encode(message.kind.value, writer.uint32(34).fork()).join();
        break;
      case "createToken":
        Action_CreateToken.encode(message.kind.value, writer.uint32(42).fork()).join();
        break;
      case "createMarket":
        Action_CreateMarket.encode(message.kind.value, writer.uint32(50).fork()).join();
        break;
      case "placeOrder":
        Action_PlaceOrder.encode(message.kind.value, writer.uint32(58).fork()).join();
        break;
      case "cancelOrderById":
        Action_CancelOrderById.encode(message.kind.value, writer.uint32(66).fork()).join();
        break;
      case "deposit":
        Action_Deposit.encode(message.kind.value, writer.uint32(74).fork()).join();
        break;
      case "withdraw":
        Action_Withdraw.encode(message.kind.value, writer.uint32(82).fork()).join();
        break;
      case "pythSetWormholeGuardians":
        Action_PythSetWormholeGuardians.encode(message.kind.value, writer.uint32(90).fork()).join();
        break;
      case "pythSetSymbolFeed":
        Action_PythSetSymbolFeed.encode(message.kind.value, writer.uint32(98).fork()).join();
        break;
      case "pythPriceFeedUpdate":
        Action_PythPriceFeedUpdate.encode(message.kind.value, writer.uint32(106).fork()).join();
        break;
      case "liquidate":
        Action_Liquidate.encode(message.kind.value, writer.uint32(114).fork()).join();
        break;
      case "revokeSession":
        Action_RevokeSession.encode(message.kind.value, writer.uint32(122).fork()).join();
        break;
      case "pause":
        Action_Pause.encode(message.kind.value, writer.uint32(130).fork()).join();
        break;
      case "unpause":
        Action_Unpause.encode(message.kind.value, writer.uint32(138).fork()).join();
        break;
      case "transfer":
        Action_Transfer.encode(message.kind.value, writer.uint32(146).fork()).join();
        break;
      case "message":
        Message.encode(message.kind.value, writer.uint32(154).fork()).join();
        break;
      case "addTrigger":
        Action_AddTrigger.encode(message.kind.value, writer.uint32(258).fork()).join();
        break;
      case "removeTrigger":
        Action_RemoveTrigger.encode(message.kind.value, writer.uint32(266).fork()).join();
        break;
      case "takePosition":
        Action_TakePosition.encode(message.kind.value, writer.uint32(274).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.currentTimestamp = reader.int64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nonce = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kind = { $case: "createSession", value: Action_CreateSession.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.kind = { $case: "createToken", value: Action_CreateToken.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.kind = { $case: "createMarket", value: Action_CreateMarket.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.kind = { $case: "placeOrder", value: Action_PlaceOrder.decode(reader, reader.uint32()) };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.kind = { $case: "cancelOrderById", value: Action_CancelOrderById.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.kind = { $case: "deposit", value: Action_Deposit.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.kind = { $case: "withdraw", value: Action_Withdraw.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.kind = {
            $case: "pythSetWormholeGuardians",
            value: Action_PythSetWormholeGuardians.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.kind = {
            $case: "pythSetSymbolFeed",
            value: Action_PythSetSymbolFeed.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.kind = {
            $case: "pythPriceFeedUpdate",
            value: Action_PythPriceFeedUpdate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.kind = { $case: "liquidate", value: Action_Liquidate.decode(reader, reader.uint32()) };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.kind = { $case: "revokeSession", value: Action_RevokeSession.decode(reader, reader.uint32()) };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.kind = { $case: "pause", value: Action_Pause.decode(reader, reader.uint32()) };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.kind = { $case: "unpause", value: Action_Unpause.decode(reader, reader.uint32()) };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.kind = { $case: "transfer", value: Action_Transfer.decode(reader, reader.uint32()) };
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.kind = { $case: "message", value: Message.decode(reader, reader.uint32()) };
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.kind = { $case: "addTrigger", value: Action_AddTrigger.decode(reader, reader.uint32()) };
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.kind = { $case: "removeTrigger", value: Action_RemoveTrigger.decode(reader, reader.uint32()) };
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.kind = { $case: "takePosition", value: Action_TakePosition.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action {
    return {
      currentTimestamp: isSet(object.currentTimestamp) ? BigInt(object.currentTimestamp) : 0n,
      nonce: isSet(object.nonce) ? globalThis.Number(object.nonce) : 0,
      kind: isSet(object.createSession)
        ? { $case: "createSession", value: Action_CreateSession.fromJSON(object.createSession) }
        : isSet(object.createToken)
        ? { $case: "createToken", value: Action_CreateToken.fromJSON(object.createToken) }
        : isSet(object.createMarket)
        ? { $case: "createMarket", value: Action_CreateMarket.fromJSON(object.createMarket) }
        : isSet(object.placeOrder)
        ? { $case: "placeOrder", value: Action_PlaceOrder.fromJSON(object.placeOrder) }
        : isSet(object.cancelOrderById)
        ? { $case: "cancelOrderById", value: Action_CancelOrderById.fromJSON(object.cancelOrderById) }
        : isSet(object.deposit)
        ? { $case: "deposit", value: Action_Deposit.fromJSON(object.deposit) }
        : isSet(object.withdraw)
        ? { $case: "withdraw", value: Action_Withdraw.fromJSON(object.withdraw) }
        : isSet(object.pythSetWormholeGuardians)
        ? {
          $case: "pythSetWormholeGuardians",
          value: Action_PythSetWormholeGuardians.fromJSON(object.pythSetWormholeGuardians),
        }
        : isSet(object.pythSetSymbolFeed)
        ? { $case: "pythSetSymbolFeed", value: Action_PythSetSymbolFeed.fromJSON(object.pythSetSymbolFeed) }
        : isSet(object.pythPriceFeedUpdate)
        ? { $case: "pythPriceFeedUpdate", value: Action_PythPriceFeedUpdate.fromJSON(object.pythPriceFeedUpdate) }
        : isSet(object.liquidate)
        ? { $case: "liquidate", value: Action_Liquidate.fromJSON(object.liquidate) }
        : isSet(object.revokeSession)
        ? { $case: "revokeSession", value: Action_RevokeSession.fromJSON(object.revokeSession) }
        : isSet(object.pause)
        ? { $case: "pause", value: Action_Pause.fromJSON(object.pause) }
        : isSet(object.unpause)
        ? { $case: "unpause", value: Action_Unpause.fromJSON(object.unpause) }
        : isSet(object.transfer)
        ? { $case: "transfer", value: Action_Transfer.fromJSON(object.transfer) }
        : isSet(object.message)
        ? { $case: "message", value: Message.fromJSON(object.message) }
        : isSet(object.addTrigger)
        ? { $case: "addTrigger", value: Action_AddTrigger.fromJSON(object.addTrigger) }
        : isSet(object.removeTrigger)
        ? { $case: "removeTrigger", value: Action_RemoveTrigger.fromJSON(object.removeTrigger) }
        : isSet(object.takePosition)
        ? { $case: "takePosition", value: Action_TakePosition.fromJSON(object.takePosition) }
        : undefined,
    };
  },

  toJSON(message: Action): unknown {
    const obj: any = {};
    if (message.currentTimestamp !== 0n) {
      obj.currentTimestamp = message.currentTimestamp.toString();
    }
    if (message.nonce !== 0) {
      obj.nonce = Math.round(message.nonce);
    }
    if (message.kind?.$case === "createSession") {
      obj.createSession = Action_CreateSession.toJSON(message.kind.value);
    } else if (message.kind?.$case === "createToken") {
      obj.createToken = Action_CreateToken.toJSON(message.kind.value);
    } else if (message.kind?.$case === "createMarket") {
      obj.createMarket = Action_CreateMarket.toJSON(message.kind.value);
    } else if (message.kind?.$case === "placeOrder") {
      obj.placeOrder = Action_PlaceOrder.toJSON(message.kind.value);
    } else if (message.kind?.$case === "cancelOrderById") {
      obj.cancelOrderById = Action_CancelOrderById.toJSON(message.kind.value);
    } else if (message.kind?.$case === "deposit") {
      obj.deposit = Action_Deposit.toJSON(message.kind.value);
    } else if (message.kind?.$case === "withdraw") {
      obj.withdraw = Action_Withdraw.toJSON(message.kind.value);
    } else if (message.kind?.$case === "pythSetWormholeGuardians") {
      obj.pythSetWormholeGuardians = Action_PythSetWormholeGuardians.toJSON(message.kind.value);
    } else if (message.kind?.$case === "pythSetSymbolFeed") {
      obj.pythSetSymbolFeed = Action_PythSetSymbolFeed.toJSON(message.kind.value);
    } else if (message.kind?.$case === "pythPriceFeedUpdate") {
      obj.pythPriceFeedUpdate = Action_PythPriceFeedUpdate.toJSON(message.kind.value);
    } else if (message.kind?.$case === "liquidate") {
      obj.liquidate = Action_Liquidate.toJSON(message.kind.value);
    } else if (message.kind?.$case === "revokeSession") {
      obj.revokeSession = Action_RevokeSession.toJSON(message.kind.value);
    } else if (message.kind?.$case === "pause") {
      obj.pause = Action_Pause.toJSON(message.kind.value);
    } else if (message.kind?.$case === "unpause") {
      obj.unpause = Action_Unpause.toJSON(message.kind.value);
    } else if (message.kind?.$case === "transfer") {
      obj.transfer = Action_Transfer.toJSON(message.kind.value);
    } else if (message.kind?.$case === "message") {
      obj.message = Message.toJSON(message.kind.value);
    } else if (message.kind?.$case === "addTrigger") {
      obj.addTrigger = Action_AddTrigger.toJSON(message.kind.value);
    } else if (message.kind?.$case === "removeTrigger") {
      obj.removeTrigger = Action_RemoveTrigger.toJSON(message.kind.value);
    } else if (message.kind?.$case === "takePosition") {
      obj.takePosition = Action_TakePosition.toJSON(message.kind.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action>, I>>(base?: I): Action {
    return Action.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action>, I>>(object: I): Action {
    const message = createBaseAction();
    message.currentTimestamp = object.currentTimestamp ?? 0n;
    message.nonce = object.nonce ?? 0;
    switch (object.kind?.$case) {
      case "createSession": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "createSession", value: Action_CreateSession.fromPartial(object.kind.value) };
        }
        break;
      }
      case "createToken": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "createToken", value: Action_CreateToken.fromPartial(object.kind.value) };
        }
        break;
      }
      case "createMarket": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "createMarket", value: Action_CreateMarket.fromPartial(object.kind.value) };
        }
        break;
      }
      case "placeOrder": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "placeOrder", value: Action_PlaceOrder.fromPartial(object.kind.value) };
        }
        break;
      }
      case "cancelOrderById": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "cancelOrderById", value: Action_CancelOrderById.fromPartial(object.kind.value) };
        }
        break;
      }
      case "deposit": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "deposit", value: Action_Deposit.fromPartial(object.kind.value) };
        }
        break;
      }
      case "withdraw": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "withdraw", value: Action_Withdraw.fromPartial(object.kind.value) };
        }
        break;
      }
      case "pythSetWormholeGuardians": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "pythSetWormholeGuardians",
            value: Action_PythSetWormholeGuardians.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "pythSetSymbolFeed": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "pythSetSymbolFeed", value: Action_PythSetSymbolFeed.fromPartial(object.kind.value) };
        }
        break;
      }
      case "pythPriceFeedUpdate": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "pythPriceFeedUpdate",
            value: Action_PythPriceFeedUpdate.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "liquidate": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "liquidate", value: Action_Liquidate.fromPartial(object.kind.value) };
        }
        break;
      }
      case "revokeSession": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "revokeSession", value: Action_RevokeSession.fromPartial(object.kind.value) };
        }
        break;
      }
      case "pause": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "pause", value: Action_Pause.fromPartial(object.kind.value) };
        }
        break;
      }
      case "unpause": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "unpause", value: Action_Unpause.fromPartial(object.kind.value) };
        }
        break;
      }
      case "transfer": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "transfer", value: Action_Transfer.fromPartial(object.kind.value) };
        }
        break;
      }
      case "message": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "message", value: Message.fromPartial(object.kind.value) };
        }
        break;
      }
      case "addTrigger": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "addTrigger", value: Action_AddTrigger.fromPartial(object.kind.value) };
        }
        break;
      }
      case "removeTrigger": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "removeTrigger", value: Action_RemoveTrigger.fromPartial(object.kind.value) };
        }
        break;
      }
      case "takePosition": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "takePosition", value: Action_TakePosition.fromPartial(object.kind.value) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAction_CreateSession(): Action_CreateSession {
  return { userPubkey: new Uint8Array(0), blstPubkey: new Uint8Array(0), expiryTimestamp: 0n };
}

export const Action_CreateSession: MessageFns<Action_CreateSession> = {
  encode(message: Action_CreateSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userPubkey.length !== 0) {
      writer.uint32(10).bytes(message.userPubkey);
    }
    if (message.blstPubkey.length !== 0) {
      writer.uint32(18).bytes(message.blstPubkey);
    }
    if (message.expiryTimestamp !== 0n) {
      if (BigInt.asIntN(64, message.expiryTimestamp) !== message.expiryTimestamp) {
        throw new globalThis.Error("value provided for field message.expiryTimestamp of type int64 too large");
      }
      writer.uint32(24).int64(message.expiryTimestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_CreateSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_CreateSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userPubkey = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blstPubkey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiryTimestamp = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_CreateSession {
    return {
      userPubkey: isSet(object.userPubkey) ? bytesFromBase64(object.userPubkey) : new Uint8Array(0),
      blstPubkey: isSet(object.blstPubkey) ? bytesFromBase64(object.blstPubkey) : new Uint8Array(0),
      expiryTimestamp: isSet(object.expiryTimestamp) ? BigInt(object.expiryTimestamp) : 0n,
    };
  },

  toJSON(message: Action_CreateSession): unknown {
    const obj: any = {};
    if (message.userPubkey.length !== 0) {
      obj.userPubkey = base64FromBytes(message.userPubkey);
    }
    if (message.blstPubkey.length !== 0) {
      obj.blstPubkey = base64FromBytes(message.blstPubkey);
    }
    if (message.expiryTimestamp !== 0n) {
      obj.expiryTimestamp = message.expiryTimestamp.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_CreateSession>, I>>(base?: I): Action_CreateSession {
    return Action_CreateSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_CreateSession>, I>>(object: I): Action_CreateSession {
    const message = createBaseAction_CreateSession();
    message.userPubkey = object.userPubkey ?? new Uint8Array(0);
    message.blstPubkey = object.blstPubkey ?? new Uint8Array(0);
    message.expiryTimestamp = object.expiryTimestamp ?? 0n;
    return message;
  },
};

function createBaseAction_CreateToken(): Action_CreateToken {
  return { tokenDecimals: 0, weightBps: 0, viewSymbol: "", oracleSymbol: "", solAddr: new Uint8Array(0) };
}

export const Action_CreateToken: MessageFns<Action_CreateToken> = {
  encode(message: Action_CreateToken, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenDecimals !== 0) {
      writer.uint32(8).uint32(message.tokenDecimals);
    }
    if (message.weightBps !== 0) {
      writer.uint32(24).uint32(message.weightBps);
    }
    if (message.viewSymbol !== "") {
      writer.uint32(34).string(message.viewSymbol);
    }
    if (message.oracleSymbol !== "") {
      writer.uint32(42).string(message.oracleSymbol);
    }
    if (message.solAddr.length !== 0) {
      writer.uint32(50).bytes(message.solAddr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_CreateToken {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_CreateToken();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tokenDecimals = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.weightBps = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.viewSymbol = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.oracleSymbol = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.solAddr = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_CreateToken {
    return {
      tokenDecimals: isSet(object.tokenDecimals) ? globalThis.Number(object.tokenDecimals) : 0,
      weightBps: isSet(object.weightBps) ? globalThis.Number(object.weightBps) : 0,
      viewSymbol: isSet(object.viewSymbol) ? globalThis.String(object.viewSymbol) : "",
      oracleSymbol: isSet(object.oracleSymbol) ? globalThis.String(object.oracleSymbol) : "",
      solAddr: isSet(object.solAddr) ? bytesFromBase64(object.solAddr) : new Uint8Array(0),
    };
  },

  toJSON(message: Action_CreateToken): unknown {
    const obj: any = {};
    if (message.tokenDecimals !== 0) {
      obj.tokenDecimals = Math.round(message.tokenDecimals);
    }
    if (message.weightBps !== 0) {
      obj.weightBps = Math.round(message.weightBps);
    }
    if (message.viewSymbol !== "") {
      obj.viewSymbol = message.viewSymbol;
    }
    if (message.oracleSymbol !== "") {
      obj.oracleSymbol = message.oracleSymbol;
    }
    if (message.solAddr.length !== 0) {
      obj.solAddr = base64FromBytes(message.solAddr);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_CreateToken>, I>>(base?: I): Action_CreateToken {
    return Action_CreateToken.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_CreateToken>, I>>(object: I): Action_CreateToken {
    const message = createBaseAction_CreateToken();
    message.tokenDecimals = object.tokenDecimals ?? 0;
    message.weightBps = object.weightBps ?? 0;
    message.viewSymbol = object.viewSymbol ?? "";
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.solAddr = object.solAddr ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAction_CreateMarket(): Action_CreateMarket {
  return {
    sizeDecimals: 0,
    priceDecimals: 0,
    imfBps: 0,
    cmfBps: 0,
    mmfBps: 0,
    marketType: 0,
    viewSymbol: "",
    oracleSymbol: "",
    baseTokenId: 0,
  };
}

export const Action_CreateMarket: MessageFns<Action_CreateMarket> = {
  encode(message: Action_CreateMarket, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sizeDecimals !== 0) {
      writer.uint32(8).uint32(message.sizeDecimals);
    }
    if (message.priceDecimals !== 0) {
      writer.uint32(16).uint32(message.priceDecimals);
    }
    if (message.imfBps !== 0) {
      writer.uint32(24).uint32(message.imfBps);
    }
    if (message.cmfBps !== 0) {
      writer.uint32(32).uint32(message.cmfBps);
    }
    if (message.mmfBps !== 0) {
      writer.uint32(40).uint32(message.mmfBps);
    }
    if (message.marketType !== 0) {
      writer.uint32(48).int32(message.marketType);
    }
    if (message.viewSymbol !== "") {
      writer.uint32(58).string(message.viewSymbol);
    }
    if (message.oracleSymbol !== "") {
      writer.uint32(66).string(message.oracleSymbol);
    }
    if (message.baseTokenId !== 0) {
      writer.uint32(72).uint32(message.baseTokenId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_CreateMarket {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_CreateMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sizeDecimals = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priceDecimals = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.imfBps = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.cmfBps = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.mmfBps = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.marketType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.viewSymbol = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.oracleSymbol = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.baseTokenId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_CreateMarket {
    return {
      sizeDecimals: isSet(object.sizeDecimals) ? globalThis.Number(object.sizeDecimals) : 0,
      priceDecimals: isSet(object.priceDecimals) ? globalThis.Number(object.priceDecimals) : 0,
      imfBps: isSet(object.imfBps) ? globalThis.Number(object.imfBps) : 0,
      cmfBps: isSet(object.cmfBps) ? globalThis.Number(object.cmfBps) : 0,
      mmfBps: isSet(object.mmfBps) ? globalThis.Number(object.mmfBps) : 0,
      marketType: isSet(object.marketType) ? marketTypeFromJSON(object.marketType) : 0,
      viewSymbol: isSet(object.viewSymbol) ? globalThis.String(object.viewSymbol) : "",
      oracleSymbol: isSet(object.oracleSymbol) ? globalThis.String(object.oracleSymbol) : "",
      baseTokenId: isSet(object.baseTokenId) ? globalThis.Number(object.baseTokenId) : 0,
    };
  },

  toJSON(message: Action_CreateMarket): unknown {
    const obj: any = {};
    if (message.sizeDecimals !== 0) {
      obj.sizeDecimals = Math.round(message.sizeDecimals);
    }
    if (message.priceDecimals !== 0) {
      obj.priceDecimals = Math.round(message.priceDecimals);
    }
    if (message.imfBps !== 0) {
      obj.imfBps = Math.round(message.imfBps);
    }
    if (message.cmfBps !== 0) {
      obj.cmfBps = Math.round(message.cmfBps);
    }
    if (message.mmfBps !== 0) {
      obj.mmfBps = Math.round(message.mmfBps);
    }
    if (message.marketType !== 0) {
      obj.marketType = marketTypeToJSON(message.marketType);
    }
    if (message.viewSymbol !== "") {
      obj.viewSymbol = message.viewSymbol;
    }
    if (message.oracleSymbol !== "") {
      obj.oracleSymbol = message.oracleSymbol;
    }
    if (message.baseTokenId !== 0) {
      obj.baseTokenId = Math.round(message.baseTokenId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_CreateMarket>, I>>(base?: I): Action_CreateMarket {
    return Action_CreateMarket.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_CreateMarket>, I>>(object: I): Action_CreateMarket {
    const message = createBaseAction_CreateMarket();
    message.sizeDecimals = object.sizeDecimals ?? 0;
    message.priceDecimals = object.priceDecimals ?? 0;
    message.imfBps = object.imfBps ?? 0;
    message.cmfBps = object.cmfBps ?? 0;
    message.mmfBps = object.mmfBps ?? 0;
    message.marketType = object.marketType ?? 0;
    message.viewSymbol = object.viewSymbol ?? "";
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.baseTokenId = object.baseTokenId ?? 0;
    return message;
  },
};

function createBaseAction_PlaceOrder(): Action_PlaceOrder {
  return {
    sessionId: 0n,
    marketId: 0,
    side: 0,
    fillMode: 0,
    isReduceOnly: false,
    price: 0n,
    size: 0n,
    quoteSize: undefined,
    delegatorAccountId: undefined,
    clientOrderId: undefined,
    senderAccountId: undefined,
  };
}

export const Action_PlaceOrder: MessageFns<Action_PlaceOrder> = {
  encode(message: Action_PlaceOrder, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.side !== 0) {
      writer.uint32(24).int32(message.side);
    }
    if (message.fillMode !== 0) {
      writer.uint32(32).int32(message.fillMode);
    }
    if (message.isReduceOnly !== false) {
      writer.uint32(40).bool(message.isReduceOnly);
    }
    if (message.price !== 0n) {
      if (BigInt.asUintN(64, message.price) !== message.price) {
        throw new globalThis.Error("value provided for field message.price of type uint64 too large");
      }
      writer.uint32(48).uint64(message.price);
    }
    if (message.size !== 0n) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(56).uint64(message.size);
    }
    if (message.quoteSize !== undefined) {
      U128.encode(message.quoteSize, writer.uint32(66).fork()).join();
    }
    if (message.delegatorAccountId !== undefined) {
      writer.uint32(256).uint32(message.delegatorAccountId);
    }
    if (message.clientOrderId !== undefined) {
      if (BigInt.asUintN(64, message.clientOrderId) !== message.clientOrderId) {
        throw new globalThis.Error("value provided for field message.clientOrderId of type uint64 too large");
      }
      writer.uint32(264).uint64(message.clientOrderId);
    }
    if (message.senderAccountId !== undefined) {
      writer.uint32(272).uint32(message.senderAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_PlaceOrder {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_PlaceOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fillMode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isReduceOnly = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.price = reader.uint64() as bigint;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.quoteSize = U128.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.delegatorAccountId = reader.uint32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.clientOrderId = reader.uint64() as bigint;
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.senderAccountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_PlaceOrder {
    return {
      sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n,
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      fillMode: isSet(object.fillMode) ? fillModeFromJSON(object.fillMode) : 0,
      isReduceOnly: isSet(object.isReduceOnly) ? globalThis.Boolean(object.isReduceOnly) : false,
      price: isSet(object.price) ? BigInt(object.price) : 0n,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      quoteSize: isSet(object.quoteSize) ? U128.fromJSON(object.quoteSize) : undefined,
      delegatorAccountId: isSet(object.delegatorAccountId) ? globalThis.Number(object.delegatorAccountId) : undefined,
      clientOrderId: isSet(object.clientOrderId) ? BigInt(object.clientOrderId) : undefined,
      senderAccountId: isSet(object.senderAccountId) ? globalThis.Number(object.senderAccountId) : undefined,
    };
  },

  toJSON(message: Action_PlaceOrder): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.fillMode !== 0) {
      obj.fillMode = fillModeToJSON(message.fillMode);
    }
    if (message.isReduceOnly !== false) {
      obj.isReduceOnly = message.isReduceOnly;
    }
    if (message.price !== 0n) {
      obj.price = message.price.toString();
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.quoteSize !== undefined) {
      obj.quoteSize = U128.toJSON(message.quoteSize);
    }
    if (message.delegatorAccountId !== undefined) {
      obj.delegatorAccountId = Math.round(message.delegatorAccountId);
    }
    if (message.clientOrderId !== undefined) {
      obj.clientOrderId = message.clientOrderId.toString();
    }
    if (message.senderAccountId !== undefined) {
      obj.senderAccountId = Math.round(message.senderAccountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_PlaceOrder>, I>>(base?: I): Action_PlaceOrder {
    return Action_PlaceOrder.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_PlaceOrder>, I>>(object: I): Action_PlaceOrder {
    const message = createBaseAction_PlaceOrder();
    message.sessionId = object.sessionId ?? 0n;
    message.marketId = object.marketId ?? 0;
    message.side = object.side ?? 0;
    message.fillMode = object.fillMode ?? 0;
    message.isReduceOnly = object.isReduceOnly ?? false;
    message.price = object.price ?? 0n;
    message.size = object.size ?? 0n;
    message.quoteSize = (object.quoteSize !== undefined && object.quoteSize !== null)
      ? U128.fromPartial(object.quoteSize)
      : undefined;
    message.delegatorAccountId = object.delegatorAccountId ?? undefined;
    message.clientOrderId = object.clientOrderId ?? undefined;
    message.senderAccountId = object.senderAccountId ?? undefined;
    return message;
  },
};

function createBaseAction_CancelOrderById(): Action_CancelOrderById {
  return { sessionId: 0n, orderId: 0n, delegatorAccountId: undefined, senderAccountId: undefined };
}

export const Action_CancelOrderById: MessageFns<Action_CancelOrderById> = {
  encode(message: Action_CancelOrderById, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.orderId !== 0n) {
      if (BigInt.asUintN(64, message.orderId) !== message.orderId) {
        throw new globalThis.Error("value provided for field message.orderId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.orderId);
    }
    if (message.delegatorAccountId !== undefined) {
      writer.uint32(256).uint32(message.delegatorAccountId);
    }
    if (message.senderAccountId !== undefined) {
      writer.uint32(264).uint32(message.senderAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_CancelOrderById {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_CancelOrderById();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.orderId = reader.uint64() as bigint;
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.delegatorAccountId = reader.uint32();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }

          message.senderAccountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_CancelOrderById {
    return {
      sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n,
      orderId: isSet(object.orderId) ? BigInt(object.orderId) : 0n,
      delegatorAccountId: isSet(object.delegatorAccountId) ? globalThis.Number(object.delegatorAccountId) : undefined,
      senderAccountId: isSet(object.senderAccountId) ? globalThis.Number(object.senderAccountId) : undefined,
    };
  },

  toJSON(message: Action_CancelOrderById): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    if (message.orderId !== 0n) {
      obj.orderId = message.orderId.toString();
    }
    if (message.delegatorAccountId !== undefined) {
      obj.delegatorAccountId = Math.round(message.delegatorAccountId);
    }
    if (message.senderAccountId !== undefined) {
      obj.senderAccountId = Math.round(message.senderAccountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_CancelOrderById>, I>>(base?: I): Action_CancelOrderById {
    return Action_CancelOrderById.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_CancelOrderById>, I>>(object: I): Action_CancelOrderById {
    const message = createBaseAction_CancelOrderById();
    message.sessionId = object.sessionId ?? 0n;
    message.orderId = object.orderId ?? 0n;
    message.delegatorAccountId = object.delegatorAccountId ?? undefined;
    message.senderAccountId = object.senderAccountId ?? undefined;
    return message;
  },
};

function createBaseAction_Deposit(): Action_Deposit {
  return { actionNonce: 0n, tokenAddr: new Uint8Array(0), amount: 0n, userPubkey: new Uint8Array(0) };
}

export const Action_Deposit: MessageFns<Action_Deposit> = {
  encode(message: Action_Deposit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionNonce !== 0n) {
      if (BigInt.asUintN(64, message.actionNonce) !== message.actionNonce) {
        throw new globalThis.Error("value provided for field message.actionNonce of type uint64 too large");
      }
      writer.uint32(8).uint64(message.actionNonce);
    }
    if (message.tokenAddr.length !== 0) {
      writer.uint32(18).bytes(message.tokenAddr);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.amount);
    }
    if (message.userPubkey.length !== 0) {
      writer.uint32(34).bytes(message.userPubkey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_Deposit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_Deposit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionNonce = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tokenAddr = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userPubkey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_Deposit {
    return {
      actionNonce: isSet(object.actionNonce) ? BigInt(object.actionNonce) : 0n,
      tokenAddr: isSet(object.tokenAddr) ? bytesFromBase64(object.tokenAddr) : new Uint8Array(0),
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
      userPubkey: isSet(object.userPubkey) ? bytesFromBase64(object.userPubkey) : new Uint8Array(0),
    };
  },

  toJSON(message: Action_Deposit): unknown {
    const obj: any = {};
    if (message.actionNonce !== 0n) {
      obj.actionNonce = message.actionNonce.toString();
    }
    if (message.tokenAddr.length !== 0) {
      obj.tokenAddr = base64FromBytes(message.tokenAddr);
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    if (message.userPubkey.length !== 0) {
      obj.userPubkey = base64FromBytes(message.userPubkey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_Deposit>, I>>(base?: I): Action_Deposit {
    return Action_Deposit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_Deposit>, I>>(object: I): Action_Deposit {
    const message = createBaseAction_Deposit();
    message.actionNonce = object.actionNonce ?? 0n;
    message.tokenAddr = object.tokenAddr ?? new Uint8Array(0);
    message.amount = object.amount ?? 0n;
    message.userPubkey = object.userPubkey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAction_Withdraw(): Action_Withdraw {
  return { tokenId: 0, sessionId: 0n, amount: 0n };
}

export const Action_Withdraw: MessageFns<Action_Withdraw> = {
  encode(message: Action_Withdraw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.sessionId);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(24).uint64(message.amount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_Withdraw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_Withdraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_Withdraw {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n,
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
    };
  },

  toJSON(message: Action_Withdraw): unknown {
    const obj: any = {};
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_Withdraw>, I>>(base?: I): Action_Withdraw {
    return Action_Withdraw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_Withdraw>, I>>(object: I): Action_Withdraw {
    const message = createBaseAction_Withdraw();
    message.tokenId = object.tokenId ?? 0;
    message.sessionId = object.sessionId ?? 0n;
    message.amount = object.amount ?? 0n;
    return message;
  },
};

function createBaseAction_PythSetWormholeGuardians(): Action_PythSetWormholeGuardians {
  return { guardianSetIndex: 0, addresses: [] };
}

export const Action_PythSetWormholeGuardians: MessageFns<Action_PythSetWormholeGuardians> = {
  encode(message: Action_PythSetWormholeGuardians, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guardianSetIndex !== 0) {
      writer.uint32(8).uint32(message.guardianSetIndex);
    }
    for (const v of message.addresses) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_PythSetWormholeGuardians {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_PythSetWormholeGuardians();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guardianSetIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addresses.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_PythSetWormholeGuardians {
    return {
      guardianSetIndex: isSet(object.guardianSetIndex) ? globalThis.Number(object.guardianSetIndex) : 0,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: Action_PythSetWormholeGuardians): unknown {
    const obj: any = {};
    if (message.guardianSetIndex !== 0) {
      obj.guardianSetIndex = Math.round(message.guardianSetIndex);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_PythSetWormholeGuardians>, I>>(base?: I): Action_PythSetWormholeGuardians {
    return Action_PythSetWormholeGuardians.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_PythSetWormholeGuardians>, I>>(
    object: I,
  ): Action_PythSetWormholeGuardians {
    const message = createBaseAction_PythSetWormholeGuardians();
    message.guardianSetIndex = object.guardianSetIndex ?? 0;
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseAction_PythSetSymbolFeed(): Action_PythSetSymbolFeed {
  return { oracleSymbol: "", priceFeedId: new Uint8Array(0) };
}

export const Action_PythSetSymbolFeed: MessageFns<Action_PythSetSymbolFeed> = {
  encode(message: Action_PythSetSymbolFeed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oracleSymbol !== "") {
      writer.uint32(10).string(message.oracleSymbol);
    }
    if (message.priceFeedId.length !== 0) {
      writer.uint32(18).bytes(message.priceFeedId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_PythSetSymbolFeed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_PythSetSymbolFeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oracleSymbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.priceFeedId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_PythSetSymbolFeed {
    return {
      oracleSymbol: isSet(object.oracleSymbol) ? globalThis.String(object.oracleSymbol) : "",
      priceFeedId: isSet(object.priceFeedId) ? bytesFromBase64(object.priceFeedId) : new Uint8Array(0),
    };
  },

  toJSON(message: Action_PythSetSymbolFeed): unknown {
    const obj: any = {};
    if (message.oracleSymbol !== "") {
      obj.oracleSymbol = message.oracleSymbol;
    }
    if (message.priceFeedId.length !== 0) {
      obj.priceFeedId = base64FromBytes(message.priceFeedId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_PythSetSymbolFeed>, I>>(base?: I): Action_PythSetSymbolFeed {
    return Action_PythSetSymbolFeed.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_PythSetSymbolFeed>, I>>(object: I): Action_PythSetSymbolFeed {
    const message = createBaseAction_PythSetSymbolFeed();
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.priceFeedId = object.priceFeedId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAction_PythPriceFeedUpdate(): Action_PythPriceFeedUpdate {
  return { rawPythnetData: new Uint8Array(0) };
}

export const Action_PythPriceFeedUpdate: MessageFns<Action_PythPriceFeedUpdate> = {
  encode(message: Action_PythPriceFeedUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rawPythnetData.length !== 0) {
      writer.uint32(10).bytes(message.rawPythnetData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_PythPriceFeedUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_PythPriceFeedUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rawPythnetData = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_PythPriceFeedUpdate {
    return {
      rawPythnetData: isSet(object.rawPythnetData) ? bytesFromBase64(object.rawPythnetData) : new Uint8Array(0),
    };
  },

  toJSON(message: Action_PythPriceFeedUpdate): unknown {
    const obj: any = {};
    if (message.rawPythnetData.length !== 0) {
      obj.rawPythnetData = base64FromBytes(message.rawPythnetData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_PythPriceFeedUpdate>, I>>(base?: I): Action_PythPriceFeedUpdate {
    return Action_PythPriceFeedUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_PythPriceFeedUpdate>, I>>(object: I): Action_PythPriceFeedUpdate {
    const message = createBaseAction_PythPriceFeedUpdate();
    message.rawPythnetData = object.rawPythnetData ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAction_Liquidate(): Action_Liquidate {
  return { liquidatorSessionId: 0n, liquidateeAccountId: 0, liquidatorAccountId: undefined };
}

export const Action_Liquidate: MessageFns<Action_Liquidate> = {
  encode(message: Action_Liquidate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.liquidatorSessionId !== 0n) {
      if (BigInt.asUintN(64, message.liquidatorSessionId) !== message.liquidatorSessionId) {
        throw new globalThis.Error("value provided for field message.liquidatorSessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.liquidatorSessionId);
    }
    if (message.liquidateeAccountId !== 0) {
      writer.uint32(16).uint32(message.liquidateeAccountId);
    }
    if (message.liquidatorAccountId !== undefined) {
      writer.uint32(24).uint32(message.liquidatorAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_Liquidate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_Liquidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.liquidatorSessionId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.liquidateeAccountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.liquidatorAccountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_Liquidate {
    return {
      liquidatorSessionId: isSet(object.liquidatorSessionId) ? BigInt(object.liquidatorSessionId) : 0n,
      liquidateeAccountId: isSet(object.liquidateeAccountId) ? globalThis.Number(object.liquidateeAccountId) : 0,
      liquidatorAccountId: isSet(object.liquidatorAccountId)
        ? globalThis.Number(object.liquidatorAccountId)
        : undefined,
    };
  },

  toJSON(message: Action_Liquidate): unknown {
    const obj: any = {};
    if (message.liquidatorSessionId !== 0n) {
      obj.liquidatorSessionId = message.liquidatorSessionId.toString();
    }
    if (message.liquidateeAccountId !== 0) {
      obj.liquidateeAccountId = Math.round(message.liquidateeAccountId);
    }
    if (message.liquidatorAccountId !== undefined) {
      obj.liquidatorAccountId = Math.round(message.liquidatorAccountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_Liquidate>, I>>(base?: I): Action_Liquidate {
    return Action_Liquidate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_Liquidate>, I>>(object: I): Action_Liquidate {
    const message = createBaseAction_Liquidate();
    message.liquidatorSessionId = object.liquidatorSessionId ?? 0n;
    message.liquidateeAccountId = object.liquidateeAccountId ?? 0;
    message.liquidatorAccountId = object.liquidatorAccountId ?? undefined;
    return message;
  },
};

function createBaseAction_RevokeSession(): Action_RevokeSession {
  return { sessionId: 0n };
}

export const Action_RevokeSession: MessageFns<Action_RevokeSession> = {
  encode(message: Action_RevokeSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_RevokeSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_RevokeSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_RevokeSession {
    return { sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n };
  },

  toJSON(message: Action_RevokeSession): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_RevokeSession>, I>>(base?: I): Action_RevokeSession {
    return Action_RevokeSession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_RevokeSession>, I>>(object: I): Action_RevokeSession {
    const message = createBaseAction_RevokeSession();
    message.sessionId = object.sessionId ?? 0n;
    return message;
  },
};

function createBaseAction_Pause(): Action_Pause {
  return {};
}

export const Action_Pause: MessageFns<Action_Pause> = {
  encode(_: Action_Pause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_Pause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_Pause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Action_Pause {
    return {};
  },

  toJSON(_: Action_Pause): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_Pause>, I>>(base?: I): Action_Pause {
    return Action_Pause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_Pause>, I>>(_: I): Action_Pause {
    const message = createBaseAction_Pause();
    return message;
  },
};

function createBaseAction_Unpause(): Action_Unpause {
  return {};
}

export const Action_Unpause: MessageFns<Action_Unpause> = {
  encode(_: Action_Unpause, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_Unpause {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_Unpause();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Action_Unpause {
    return {};
  },

  toJSON(_: Action_Unpause): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_Unpause>, I>>(base?: I): Action_Unpause {
    return Action_Unpause.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_Unpause>, I>>(_: I): Action_Unpause {
    const message = createBaseAction_Unpause();
    return message;
  },
};

function createBaseAction_Transfer(): Action_Transfer {
  return { sessionId: 0n, fromAccountId: 0, tokenId: 0, amount: 0n, toAccountId: undefined, specialAccount: undefined };
}

export const Action_Transfer: MessageFns<Action_Transfer> = {
  encode(message: Action_Transfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.fromAccountId !== 0) {
      writer.uint32(16).uint32(message.fromAccountId);
    }
    if (message.tokenId !== 0) {
      writer.uint32(24).uint32(message.tokenId);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.amount);
    }
    if (message.toAccountId !== undefined) {
      writer.uint32(64).uint32(message.toAccountId);
    }
    if (message.specialAccount !== undefined) {
      writer.uint32(72).int32(message.specialAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_Transfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_Transfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fromAccountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.toAccountId = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.specialAccount = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_Transfer {
    return {
      sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n,
      fromAccountId: isSet(object.fromAccountId) ? globalThis.Number(object.fromAccountId) : 0,
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
      toAccountId: isSet(object.toAccountId) ? globalThis.Number(object.toAccountId) : undefined,
      specialAccount: isSet(object.specialAccount) ? specialAccountFromJSON(object.specialAccount) : undefined,
    };
  },

  toJSON(message: Action_Transfer): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    if (message.fromAccountId !== 0) {
      obj.fromAccountId = Math.round(message.fromAccountId);
    }
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    if (message.toAccountId !== undefined) {
      obj.toAccountId = Math.round(message.toAccountId);
    }
    if (message.specialAccount !== undefined) {
      obj.specialAccount = specialAccountToJSON(message.specialAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_Transfer>, I>>(base?: I): Action_Transfer {
    return Action_Transfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_Transfer>, I>>(object: I): Action_Transfer {
    const message = createBaseAction_Transfer();
    message.sessionId = object.sessionId ?? 0n;
    message.fromAccountId = object.fromAccountId ?? 0;
    message.tokenId = object.tokenId ?? 0;
    message.amount = object.amount ?? 0n;
    message.toAccountId = object.toAccountId ?? undefined;
    message.specialAccount = object.specialAccount ?? undefined;
    return message;
  },
};

function createBaseAction_AddTrigger(): Action_AddTrigger {
  return { sessionId: 0n, marketId: 0, kind: 0, side: 0, price: 0n, accountId: undefined };
}

export const Action_AddTrigger: MessageFns<Action_AddTrigger> = {
  encode(message: Action_AddTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    if (message.side !== 0) {
      writer.uint32(32).int32(message.side);
    }
    if (message.price !== 0n) {
      if (BigInt.asUintN(64, message.price) !== message.price) {
        throw new globalThis.Error("value provided for field message.price of type uint64 too large");
      }
      writer.uint32(40).uint64(message.price);
    }
    if (message.accountId !== undefined) {
      writer.uint32(80).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_AddTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_AddTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.price = reader.uint64() as bigint;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_AddTrigger {
    return {
      sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n,
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      kind: isSet(object.kind) ? triggerKindFromJSON(object.kind) : 0,
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      price: isSet(object.price) ? BigInt(object.price) : 0n,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : undefined,
    };
  },

  toJSON(message: Action_AddTrigger): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.kind !== 0) {
      obj.kind = triggerKindToJSON(message.kind);
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.price !== 0n) {
      obj.price = message.price.toString();
    }
    if (message.accountId !== undefined) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_AddTrigger>, I>>(base?: I): Action_AddTrigger {
    return Action_AddTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_AddTrigger>, I>>(object: I): Action_AddTrigger {
    const message = createBaseAction_AddTrigger();
    message.sessionId = object.sessionId ?? 0n;
    message.marketId = object.marketId ?? 0;
    message.kind = object.kind ?? 0;
    message.side = object.side ?? 0;
    message.price = object.price ?? 0n;
    message.accountId = object.accountId ?? undefined;
    return message;
  },
};

function createBaseAction_RemoveTrigger(): Action_RemoveTrigger {
  return { sessionId: 0n, marketId: 0, kind: 0, side: 0, accountId: undefined };
}

export const Action_RemoveTrigger: MessageFns<Action_RemoveTrigger> = {
  encode(message: Action_RemoveTrigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    if (message.side !== 0) {
      writer.uint32(32).int32(message.side);
    }
    if (message.accountId !== undefined) {
      writer.uint32(80).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_RemoveTrigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_RemoveTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_RemoveTrigger {
    return {
      sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n,
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      kind: isSet(object.kind) ? triggerKindFromJSON(object.kind) : 0,
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : undefined,
    };
  },

  toJSON(message: Action_RemoveTrigger): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.kind !== 0) {
      obj.kind = triggerKindToJSON(message.kind);
    }
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.accountId !== undefined) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_RemoveTrigger>, I>>(base?: I): Action_RemoveTrigger {
    return Action_RemoveTrigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_RemoveTrigger>, I>>(object: I): Action_RemoveTrigger {
    const message = createBaseAction_RemoveTrigger();
    message.sessionId = object.sessionId ?? 0n;
    message.marketId = object.marketId ?? 0;
    message.kind = object.kind ?? 0;
    message.side = object.side ?? 0;
    message.accountId = object.accountId ?? undefined;
    return message;
  },
};

function createBaseAction_TakePosition(): Action_TakePosition {
  return { sessionId: 0n, marketId: 0, size: 0n, senderAccountId: undefined, price: undefined };
}

export const Action_TakePosition: MessageFns<Action_TakePosition> = {
  encode(message: Action_TakePosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.size !== 0n) {
      if (BigInt.asIntN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type int64 too large");
      }
      writer.uint32(24).int64(message.size);
    }
    if (message.senderAccountId !== undefined) {
      writer.uint32(32).uint32(message.senderAccountId);
    }
    if (message.price !== undefined) {
      if (BigInt.asUintN(64, message.price) !== message.price) {
        throw new globalThis.Error("value provided for field message.price of type uint64 too large");
      }
      writer.uint32(40).uint64(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Action_TakePosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAction_TakePosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = reader.int64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.senderAccountId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.price = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Action_TakePosition {
    return {
      sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n,
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      senderAccountId: isSet(object.senderAccountId) ? globalThis.Number(object.senderAccountId) : undefined,
      price: isSet(object.price) ? BigInt(object.price) : undefined,
    };
  },

  toJSON(message: Action_TakePosition): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.senderAccountId !== undefined) {
      obj.senderAccountId = Math.round(message.senderAccountId);
    }
    if (message.price !== undefined) {
      obj.price = message.price.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Action_TakePosition>, I>>(base?: I): Action_TakePosition {
    return Action_TakePosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Action_TakePosition>, I>>(object: I): Action_TakePosition {
    const message = createBaseAction_TakePosition();
    message.sessionId = object.sessionId ?? 0n;
    message.marketId = object.marketId ?? 0;
    message.size = object.size ?? 0n;
    message.senderAccountId = object.senderAccountId ?? undefined;
    message.price = object.price ?? undefined;
    return message;
  },
};

function createBaseReceipt(): Receipt {
  return { actionId: 0n, kind: undefined };
}

export const Receipt: MessageFns<Receipt> = {
  encode(message: Receipt, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionId !== 0n) {
      if (BigInt.asUintN(64, message.actionId) !== message.actionId) {
        throw new globalThis.Error("value provided for field message.actionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.actionId);
    }
    switch (message.kind?.$case) {
      case "err":
        writer.uint32(256).int32(message.kind.value);
        break;
      case "createSessionResult":
        Receipt_CreateSessionResult.encode(message.kind.value, writer.uint32(266).fork()).join();
        break;
      case "placeOrderResult":
        Receipt_PlaceOrderResult.encode(message.kind.value, writer.uint32(274).fork()).join();
        break;
      case "cancelOrderResult":
        Receipt_CancelOrderResult.encode(message.kind.value, writer.uint32(282).fork()).join();
        break;
      case "depositResult":
        Receipt_DepositResult.encode(message.kind.value, writer.uint32(290).fork()).join();
        break;
      case "insertTokenResult":
        Receipt_InsertTokenResult.encode(message.kind.value, writer.uint32(298).fork()).join();
        break;
      case "insertMarketResult":
        Receipt_InsertMarketResult.encode(message.kind.value, writer.uint32(306).fork()).join();
        break;
      case "withdrawResult":
        Receipt_WithdrawResult.encode(message.kind.value, writer.uint32(314).fork()).join();
        break;
      case "oracleSymbolFeedResult":
        Receipt_OracleSymbolFeedResult.encode(message.kind.value, writer.uint32(322).fork()).join();
        break;
      case "oracleUpdateResult":
        Receipt_OracleUpdateResult.encode(message.kind.value, writer.uint32(330).fork()).join();
        break;
      case "updateGuardianSetResult":
        Receipt_UpdateGuardianSetResult.encode(message.kind.value, writer.uint32(338).fork()).join();
        break;
      case "liquidated":
        Receipt_AccountLiquidated.encode(message.kind.value, writer.uint32(346).fork()).join();
        break;
      case "sessionRevoked":
        Receipt_SessionRevoked.encode(message.kind.value, writer.uint32(354).fork()).join();
        break;
      case "paused":
        Receipt_Paused.encode(message.kind.value, writer.uint32(362).fork()).join();
        break;
      case "unpaused":
        Receipt_Unpaused.encode(message.kind.value, writer.uint32(370).fork()).join();
        break;
      case "transferred":
        Receipt_Transferred.encode(message.kind.value, writer.uint32(378).fork()).join();
        break;
      case "triggerAdded":
        Receipt_TriggerAdded.encode(message.kind.value, writer.uint32(514).fork()).join();
        break;
      case "triggerRemoved":
        Receipt_TriggerRemoved.encode(message.kind.value, writer.uint32(522).fork()).join();
        break;
      case "positionTakenOrTraded":
        Receipt_PositionTakenOrTradedResult.encode(message.kind.value, writer.uint32(530).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionId = reader.uint64() as bigint;
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }

          message.kind = { $case: "err", value: reader.int32() as any };
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.kind = {
            $case: "createSessionResult",
            value: Receipt_CreateSessionResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.kind = { $case: "placeOrderResult", value: Receipt_PlaceOrderResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.kind = {
            $case: "cancelOrderResult",
            value: Receipt_CancelOrderResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.kind = { $case: "depositResult", value: Receipt_DepositResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.kind = {
            $case: "insertTokenResult",
            value: Receipt_InsertTokenResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.kind = {
            $case: "insertMarketResult",
            value: Receipt_InsertMarketResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }

          message.kind = { $case: "withdrawResult", value: Receipt_WithdrawResult.decode(reader, reader.uint32()) };
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }

          message.kind = {
            $case: "oracleSymbolFeedResult",
            value: Receipt_OracleSymbolFeedResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.kind = {
            $case: "oracleUpdateResult",
            value: Receipt_OracleUpdateResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.kind = {
            $case: "updateGuardianSetResult",
            value: Receipt_UpdateGuardianSetResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.kind = { $case: "liquidated", value: Receipt_AccountLiquidated.decode(reader, reader.uint32()) };
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.kind = { $case: "sessionRevoked", value: Receipt_SessionRevoked.decode(reader, reader.uint32()) };
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.kind = { $case: "paused", value: Receipt_Paused.decode(reader, reader.uint32()) };
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.kind = { $case: "unpaused", value: Receipt_Unpaused.decode(reader, reader.uint32()) };
          continue;
        }
        case 47: {
          if (tag !== 378) {
            break;
          }

          message.kind = { $case: "transferred", value: Receipt_Transferred.decode(reader, reader.uint32()) };
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.kind = { $case: "triggerAdded", value: Receipt_TriggerAdded.decode(reader, reader.uint32()) };
          continue;
        }
        case 65: {
          if (tag !== 522) {
            break;
          }

          message.kind = { $case: "triggerRemoved", value: Receipt_TriggerRemoved.decode(reader, reader.uint32()) };
          continue;
        }
        case 66: {
          if (tag !== 530) {
            break;
          }

          message.kind = {
            $case: "positionTakenOrTraded",
            value: Receipt_PositionTakenOrTradedResult.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt {
    return {
      actionId: isSet(object.actionId) ? BigInt(object.actionId) : 0n,
      kind: isSet(object.err)
        ? { $case: "err", value: errorFromJSON(object.err) }
        : isSet(object.createSessionResult)
        ? { $case: "createSessionResult", value: Receipt_CreateSessionResult.fromJSON(object.createSessionResult) }
        : isSet(object.placeOrderResult)
        ? { $case: "placeOrderResult", value: Receipt_PlaceOrderResult.fromJSON(object.placeOrderResult) }
        : isSet(object.cancelOrderResult)
        ? { $case: "cancelOrderResult", value: Receipt_CancelOrderResult.fromJSON(object.cancelOrderResult) }
        : isSet(object.depositResult)
        ? { $case: "depositResult", value: Receipt_DepositResult.fromJSON(object.depositResult) }
        : isSet(object.insertTokenResult)
        ? { $case: "insertTokenResult", value: Receipt_InsertTokenResult.fromJSON(object.insertTokenResult) }
        : isSet(object.insertMarketResult)
        ? { $case: "insertMarketResult", value: Receipt_InsertMarketResult.fromJSON(object.insertMarketResult) }
        : isSet(object.withdrawResult)
        ? { $case: "withdrawResult", value: Receipt_WithdrawResult.fromJSON(object.withdrawResult) }
        : isSet(object.oracleSymbolFeedResult)
        ? {
          $case: "oracleSymbolFeedResult",
          value: Receipt_OracleSymbolFeedResult.fromJSON(object.oracleSymbolFeedResult),
        }
        : isSet(object.oracleUpdateResult)
        ? { $case: "oracleUpdateResult", value: Receipt_OracleUpdateResult.fromJSON(object.oracleUpdateResult) }
        : isSet(object.updateGuardianSetResult)
        ? {
          $case: "updateGuardianSetResult",
          value: Receipt_UpdateGuardianSetResult.fromJSON(object.updateGuardianSetResult),
        }
        : isSet(object.liquidated)
        ? { $case: "liquidated", value: Receipt_AccountLiquidated.fromJSON(object.liquidated) }
        : isSet(object.sessionRevoked)
        ? { $case: "sessionRevoked", value: Receipt_SessionRevoked.fromJSON(object.sessionRevoked) }
        : isSet(object.paused)
        ? { $case: "paused", value: Receipt_Paused.fromJSON(object.paused) }
        : isSet(object.unpaused)
        ? { $case: "unpaused", value: Receipt_Unpaused.fromJSON(object.unpaused) }
        : isSet(object.transferred)
        ? { $case: "transferred", value: Receipt_Transferred.fromJSON(object.transferred) }
        : isSet(object.triggerAdded)
        ? { $case: "triggerAdded", value: Receipt_TriggerAdded.fromJSON(object.triggerAdded) }
        : isSet(object.triggerRemoved)
        ? { $case: "triggerRemoved", value: Receipt_TriggerRemoved.fromJSON(object.triggerRemoved) }
        : isSet(object.positionTakenOrTraded)
        ? {
          $case: "positionTakenOrTraded",
          value: Receipt_PositionTakenOrTradedResult.fromJSON(object.positionTakenOrTraded),
        }
        : undefined,
    };
  },

  toJSON(message: Receipt): unknown {
    const obj: any = {};
    if (message.actionId !== 0n) {
      obj.actionId = message.actionId.toString();
    }
    if (message.kind?.$case === "err") {
      obj.err = errorToJSON(message.kind.value);
    } else if (message.kind?.$case === "createSessionResult") {
      obj.createSessionResult = Receipt_CreateSessionResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "placeOrderResult") {
      obj.placeOrderResult = Receipt_PlaceOrderResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "cancelOrderResult") {
      obj.cancelOrderResult = Receipt_CancelOrderResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "depositResult") {
      obj.depositResult = Receipt_DepositResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "insertTokenResult") {
      obj.insertTokenResult = Receipt_InsertTokenResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "insertMarketResult") {
      obj.insertMarketResult = Receipt_InsertMarketResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "withdrawResult") {
      obj.withdrawResult = Receipt_WithdrawResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "oracleSymbolFeedResult") {
      obj.oracleSymbolFeedResult = Receipt_OracleSymbolFeedResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "oracleUpdateResult") {
      obj.oracleUpdateResult = Receipt_OracleUpdateResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "updateGuardianSetResult") {
      obj.updateGuardianSetResult = Receipt_UpdateGuardianSetResult.toJSON(message.kind.value);
    } else if (message.kind?.$case === "liquidated") {
      obj.liquidated = Receipt_AccountLiquidated.toJSON(message.kind.value);
    } else if (message.kind?.$case === "sessionRevoked") {
      obj.sessionRevoked = Receipt_SessionRevoked.toJSON(message.kind.value);
    } else if (message.kind?.$case === "paused") {
      obj.paused = Receipt_Paused.toJSON(message.kind.value);
    } else if (message.kind?.$case === "unpaused") {
      obj.unpaused = Receipt_Unpaused.toJSON(message.kind.value);
    } else if (message.kind?.$case === "transferred") {
      obj.transferred = Receipt_Transferred.toJSON(message.kind.value);
    } else if (message.kind?.$case === "triggerAdded") {
      obj.triggerAdded = Receipt_TriggerAdded.toJSON(message.kind.value);
    } else if (message.kind?.$case === "triggerRemoved") {
      obj.triggerRemoved = Receipt_TriggerRemoved.toJSON(message.kind.value);
    } else if (message.kind?.$case === "positionTakenOrTraded") {
      obj.positionTakenOrTraded = Receipt_PositionTakenOrTradedResult.toJSON(message.kind.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt>, I>>(base?: I): Receipt {
    return Receipt.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt>, I>>(object: I): Receipt {
    const message = createBaseReceipt();
    message.actionId = object.actionId ?? 0n;
    switch (object.kind?.$case) {
      case "err": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "err", value: object.kind.value };
        }
        break;
      }
      case "createSessionResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "createSessionResult",
            value: Receipt_CreateSessionResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "placeOrderResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "placeOrderResult", value: Receipt_PlaceOrderResult.fromPartial(object.kind.value) };
        }
        break;
      }
      case "cancelOrderResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "cancelOrderResult",
            value: Receipt_CancelOrderResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "depositResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "depositResult", value: Receipt_DepositResult.fromPartial(object.kind.value) };
        }
        break;
      }
      case "insertTokenResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "insertTokenResult",
            value: Receipt_InsertTokenResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "insertMarketResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "insertMarketResult",
            value: Receipt_InsertMarketResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "withdrawResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "withdrawResult", value: Receipt_WithdrawResult.fromPartial(object.kind.value) };
        }
        break;
      }
      case "oracleSymbolFeedResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "oracleSymbolFeedResult",
            value: Receipt_OracleSymbolFeedResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "oracleUpdateResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "oracleUpdateResult",
            value: Receipt_OracleUpdateResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "updateGuardianSetResult": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "updateGuardianSetResult",
            value: Receipt_UpdateGuardianSetResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
      case "liquidated": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "liquidated", value: Receipt_AccountLiquidated.fromPartial(object.kind.value) };
        }
        break;
      }
      case "sessionRevoked": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "sessionRevoked", value: Receipt_SessionRevoked.fromPartial(object.kind.value) };
        }
        break;
      }
      case "paused": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "paused", value: Receipt_Paused.fromPartial(object.kind.value) };
        }
        break;
      }
      case "unpaused": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "unpaused", value: Receipt_Unpaused.fromPartial(object.kind.value) };
        }
        break;
      }
      case "transferred": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "transferred", value: Receipt_Transferred.fromPartial(object.kind.value) };
        }
        break;
      }
      case "triggerAdded": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "triggerAdded", value: Receipt_TriggerAdded.fromPartial(object.kind.value) };
        }
        break;
      }
      case "triggerRemoved": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = { $case: "triggerRemoved", value: Receipt_TriggerRemoved.fromPartial(object.kind.value) };
        }
        break;
      }
      case "positionTakenOrTraded": {
        if (object.kind?.value !== undefined && object.kind?.value !== null) {
          message.kind = {
            $case: "positionTakenOrTraded",
            value: Receipt_PositionTakenOrTradedResult.fromPartial(object.kind.value),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseReceipt_Posted(): Receipt_Posted {
  return { side: 0, marketId: 0, price: 0n, size: 0n, orderId: 0n, accountId: 0 };
}

export const Receipt_Posted: MessageFns<Receipt_Posted> = {
  encode(message: Receipt_Posted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.side !== 0) {
      writer.uint32(8).int32(message.side);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.price !== 0n) {
      if (BigInt.asUintN(64, message.price) !== message.price) {
        throw new globalThis.Error("value provided for field message.price of type uint64 too large");
      }
      writer.uint32(24).uint64(message.price);
    }
    if (message.size !== 0n) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(32).uint64(message.size);
    }
    if (message.orderId !== 0n) {
      if (BigInt.asUintN(64, message.orderId) !== message.orderId) {
        throw new globalThis.Error("value provided for field message.orderId of type uint64 too large");
      }
      writer.uint32(40).uint64(message.orderId);
    }
    if (message.accountId !== 0) {
      writer.uint32(48).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_Posted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_Posted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.price = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.orderId = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_Posted {
    return {
      side: isSet(object.side) ? sideFromJSON(object.side) : 0,
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      price: isSet(object.price) ? BigInt(object.price) : 0n,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      orderId: isSet(object.orderId) ? BigInt(object.orderId) : 0n,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
    };
  },

  toJSON(message: Receipt_Posted): unknown {
    const obj: any = {};
    if (message.side !== 0) {
      obj.side = sideToJSON(message.side);
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.price !== 0n) {
      obj.price = message.price.toString();
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.orderId !== 0n) {
      obj.orderId = message.orderId.toString();
    }
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_Posted>, I>>(base?: I): Receipt_Posted {
    return Receipt_Posted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_Posted>, I>>(object: I): Receipt_Posted {
    const message = createBaseReceipt_Posted();
    message.side = object.side ?? 0;
    message.marketId = object.marketId ?? 0;
    message.price = object.price ?? 0n;
    message.size = object.size ?? 0n;
    message.orderId = object.orderId ?? 0n;
    message.accountId = object.accountId ?? 0;
    return message;
  },
};

function createBaseReceipt_Trade(): Receipt_Trade {
  return { orderId: 0n, price: 0n, size: 0n, accountId: 0 };
}

export const Receipt_Trade: MessageFns<Receipt_Trade> = {
  encode(message: Receipt_Trade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== 0n) {
      if (BigInt.asUintN(64, message.orderId) !== message.orderId) {
        throw new globalThis.Error("value provided for field message.orderId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.orderId);
    }
    if (message.price !== 0n) {
      if (BigInt.asUintN(64, message.price) !== message.price) {
        throw new globalThis.Error("value provided for field message.price of type uint64 too large");
      }
      writer.uint32(32).uint64(message.price);
    }
    if (message.size !== 0n) {
      if (BigInt.asUintN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type uint64 too large");
      }
      writer.uint32(40).uint64(message.size);
    }
    if (message.accountId !== 0) {
      writer.uint32(48).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_Trade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_Trade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.orderId = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.price = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.size = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_Trade {
    return {
      orderId: isSet(object.orderId) ? BigInt(object.orderId) : 0n,
      price: isSet(object.price) ? BigInt(object.price) : 0n,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
    };
  },

  toJSON(message: Receipt_Trade): unknown {
    const obj: any = {};
    if (message.orderId !== 0n) {
      obj.orderId = message.orderId.toString();
    }
    if (message.price !== 0n) {
      obj.price = message.price.toString();
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_Trade>, I>>(base?: I): Receipt_Trade {
    return Receipt_Trade.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_Trade>, I>>(object: I): Receipt_Trade {
    const message = createBaseReceipt_Trade();
    message.orderId = object.orderId ?? 0n;
    message.price = object.price ?? 0n;
    message.size = object.size ?? 0n;
    message.accountId = object.accountId ?? 0;
    return message;
  },
};

function createBaseReceipt_CreateSessionResult(): Receipt_CreateSessionResult {
  return { sessionId: 0n };
}

export const Receipt_CreateSessionResult: MessageFns<Receipt_CreateSessionResult> = {
  encode(message: Receipt_CreateSessionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== 0n) {
      if (BigInt.asUintN(64, message.sessionId) !== message.sessionId) {
        throw new globalThis.Error("value provided for field message.sessionId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_CreateSessionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_CreateSessionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sessionId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_CreateSessionResult {
    return { sessionId: isSet(object.sessionId) ? BigInt(object.sessionId) : 0n };
  },

  toJSON(message: Receipt_CreateSessionResult): unknown {
    const obj: any = {};
    if (message.sessionId !== 0n) {
      obj.sessionId = message.sessionId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_CreateSessionResult>, I>>(base?: I): Receipt_CreateSessionResult {
    return Receipt_CreateSessionResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_CreateSessionResult>, I>>(object: I): Receipt_CreateSessionResult {
    const message = createBaseReceipt_CreateSessionResult();
    message.sessionId = object.sessionId ?? 0n;
    return message;
  },
};

function createBaseReceipt_PlaceOrderResult(): Receipt_PlaceOrderResult {
  return { posted: undefined, fills: [], clientOrderId: undefined };
}

export const Receipt_PlaceOrderResult: MessageFns<Receipt_PlaceOrderResult> = {
  encode(message: Receipt_PlaceOrderResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.posted !== undefined) {
      Receipt_Posted.encode(message.posted, writer.uint32(10).fork()).join();
    }
    for (const v of message.fills) {
      Receipt_Trade.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.clientOrderId !== undefined) {
      if (BigInt.asUintN(64, message.clientOrderId) !== message.clientOrderId) {
        throw new globalThis.Error("value provided for field message.clientOrderId of type uint64 too large");
      }
      writer.uint32(24).uint64(message.clientOrderId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_PlaceOrderResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_PlaceOrderResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.posted = Receipt_Posted.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fills.push(Receipt_Trade.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.clientOrderId = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_PlaceOrderResult {
    return {
      posted: isSet(object.posted) ? Receipt_Posted.fromJSON(object.posted) : undefined,
      fills: globalThis.Array.isArray(object?.fills) ? object.fills.map((e: any) => Receipt_Trade.fromJSON(e)) : [],
      clientOrderId: isSet(object.clientOrderId) ? BigInt(object.clientOrderId) : undefined,
    };
  },

  toJSON(message: Receipt_PlaceOrderResult): unknown {
    const obj: any = {};
    if (message.posted !== undefined) {
      obj.posted = Receipt_Posted.toJSON(message.posted);
    }
    if (message.fills?.length) {
      obj.fills = message.fills.map((e) => Receipt_Trade.toJSON(e));
    }
    if (message.clientOrderId !== undefined) {
      obj.clientOrderId = message.clientOrderId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_PlaceOrderResult>, I>>(base?: I): Receipt_PlaceOrderResult {
    return Receipt_PlaceOrderResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_PlaceOrderResult>, I>>(object: I): Receipt_PlaceOrderResult {
    const message = createBaseReceipt_PlaceOrderResult();
    message.posted = (object.posted !== undefined && object.posted !== null)
      ? Receipt_Posted.fromPartial(object.posted)
      : undefined;
    message.fills = object.fills?.map((e) => Receipt_Trade.fromPartial(e)) || [];
    message.clientOrderId = object.clientOrderId ?? undefined;
    return message;
  },
};

function createBaseReceipt_TakenResult(): Receipt_TakenResult {
  return { pnl: 0n, size: 0n, takerAccountId: 0 };
}

export const Receipt_TakenResult: MessageFns<Receipt_TakenResult> = {
  encode(message: Receipt_TakenResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pnl !== 0n) {
      if (BigInt.asIntN(64, message.pnl) !== message.pnl) {
        throw new globalThis.Error("value provided for field message.pnl of type int64 too large");
      }
      writer.uint32(8).int64(message.pnl);
    }
    if (message.size !== 0n) {
      if (BigInt.asIntN(64, message.size) !== message.size) {
        throw new globalThis.Error("value provided for field message.size of type int64 too large");
      }
      writer.uint32(16).int64(message.size);
    }
    if (message.takerAccountId !== 0) {
      writer.uint32(24).uint32(message.takerAccountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_TakenResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_TakenResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pnl = reader.int64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = reader.int64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.takerAccountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_TakenResult {
    return {
      pnl: isSet(object.pnl) ? BigInt(object.pnl) : 0n,
      size: isSet(object.size) ? BigInt(object.size) : 0n,
      takerAccountId: isSet(object.takerAccountId) ? globalThis.Number(object.takerAccountId) : 0,
    };
  },

  toJSON(message: Receipt_TakenResult): unknown {
    const obj: any = {};
    if (message.pnl !== 0n) {
      obj.pnl = message.pnl.toString();
    }
    if (message.size !== 0n) {
      obj.size = message.size.toString();
    }
    if (message.takerAccountId !== 0) {
      obj.takerAccountId = Math.round(message.takerAccountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_TakenResult>, I>>(base?: I): Receipt_TakenResult {
    return Receipt_TakenResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_TakenResult>, I>>(object: I): Receipt_TakenResult {
    const message = createBaseReceipt_TakenResult();
    message.pnl = object.pnl ?? 0n;
    message.size = object.size ?? 0n;
    message.takerAccountId = object.takerAccountId ?? 0;
    return message;
  },
};

function createBaseReceipt_PositionTakenOrTradedResult(): Receipt_PositionTakenOrTradedResult {
  return { marketId: 0, PositionTakenOrTradedKind: undefined };
}

export const Receipt_PositionTakenOrTradedResult: MessageFns<Receipt_PositionTakenOrTradedResult> = {
  encode(message: Receipt_PositionTakenOrTradedResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    switch (message.PositionTakenOrTradedKind?.$case) {
      case "taken":
        Receipt_TakenResult.encode(message.PositionTakenOrTradedKind.value, writer.uint32(18).fork()).join();
        break;
      case "traded":
        Receipt_PlaceOrderResult.encode(message.PositionTakenOrTradedKind.value, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_PositionTakenOrTradedResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_PositionTakenOrTradedResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.PositionTakenOrTradedKind = {
            $case: "taken",
            value: Receipt_TakenResult.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.PositionTakenOrTradedKind = {
            $case: "traded",
            value: Receipt_PlaceOrderResult.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_PositionTakenOrTradedResult {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      PositionTakenOrTradedKind: isSet(object.taken)
        ? { $case: "taken", value: Receipt_TakenResult.fromJSON(object.taken) }
        : isSet(object.traded)
        ? { $case: "traded", value: Receipt_PlaceOrderResult.fromJSON(object.traded) }
        : undefined,
    };
  },

  toJSON(message: Receipt_PositionTakenOrTradedResult): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.PositionTakenOrTradedKind?.$case === "taken") {
      obj.taken = Receipt_TakenResult.toJSON(message.PositionTakenOrTradedKind.value);
    } else if (message.PositionTakenOrTradedKind?.$case === "traded") {
      obj.traded = Receipt_PlaceOrderResult.toJSON(message.PositionTakenOrTradedKind.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_PositionTakenOrTradedResult>, I>>(
    base?: I,
  ): Receipt_PositionTakenOrTradedResult {
    return Receipt_PositionTakenOrTradedResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_PositionTakenOrTradedResult>, I>>(
    object: I,
  ): Receipt_PositionTakenOrTradedResult {
    const message = createBaseReceipt_PositionTakenOrTradedResult();
    message.marketId = object.marketId ?? 0;
    switch (object.PositionTakenOrTradedKind?.$case) {
      case "taken": {
        if (object.PositionTakenOrTradedKind?.value !== undefined && object.PositionTakenOrTradedKind?.value !== null) {
          message.PositionTakenOrTradedKind = {
            $case: "taken",
            value: Receipt_TakenResult.fromPartial(object.PositionTakenOrTradedKind.value),
          };
        }
        break;
      }
      case "traded": {
        if (object.PositionTakenOrTradedKind?.value !== undefined && object.PositionTakenOrTradedKind?.value !== null) {
          message.PositionTakenOrTradedKind = {
            $case: "traded",
            value: Receipt_PlaceOrderResult.fromPartial(object.PositionTakenOrTradedKind.value),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseReceipt_CancelOrderResult(): Receipt_CancelOrderResult {
  return { orderId: 0n, accountId: 0 };
}

export const Receipt_CancelOrderResult: MessageFns<Receipt_CancelOrderResult> = {
  encode(message: Receipt_CancelOrderResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== 0n) {
      if (BigInt.asUintN(64, message.orderId) !== message.orderId) {
        throw new globalThis.Error("value provided for field message.orderId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.orderId);
    }
    if (message.accountId !== 0) {
      writer.uint32(16).uint32(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_CancelOrderResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_CancelOrderResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_CancelOrderResult {
    return {
      orderId: isSet(object.orderId) ? BigInt(object.orderId) : 0n,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
    };
  },

  toJSON(message: Receipt_CancelOrderResult): unknown {
    const obj: any = {};
    if (message.orderId !== 0n) {
      obj.orderId = message.orderId.toString();
    }
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_CancelOrderResult>, I>>(base?: I): Receipt_CancelOrderResult {
    return Receipt_CancelOrderResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_CancelOrderResult>, I>>(object: I): Receipt_CancelOrderResult {
    const message = createBaseReceipt_CancelOrderResult();
    message.orderId = object.orderId ?? 0n;
    message.accountId = object.accountId ?? 0;
    return message;
  },
};

function createBaseReceipt_DepositResult(): Receipt_DepositResult {
  return { tokenId: 0, amount: 0n, accountId: 0, userCreated: false, userPubkey: new Uint8Array(0) };
}

export const Receipt_DepositResult: MessageFns<Receipt_DepositResult> = {
  encode(message: Receipt_DepositResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.amount);
    }
    if (message.accountId !== 0) {
      writer.uint32(24).uint32(message.accountId);
    }
    if (message.userCreated !== false) {
      writer.uint32(32).bool(message.userCreated);
    }
    if (message.userPubkey.length !== 0) {
      writer.uint32(42).bytes(message.userPubkey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_DepositResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_DepositResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.userCreated = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userPubkey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_DepositResult {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      userCreated: isSet(object.userCreated) ? globalThis.Boolean(object.userCreated) : false,
      userPubkey: isSet(object.userPubkey) ? bytesFromBase64(object.userPubkey) : new Uint8Array(0),
    };
  },

  toJSON(message: Receipt_DepositResult): unknown {
    const obj: any = {};
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.userCreated !== false) {
      obj.userCreated = message.userCreated;
    }
    if (message.userPubkey.length !== 0) {
      obj.userPubkey = base64FromBytes(message.userPubkey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_DepositResult>, I>>(base?: I): Receipt_DepositResult {
    return Receipt_DepositResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_DepositResult>, I>>(object: I): Receipt_DepositResult {
    const message = createBaseReceipt_DepositResult();
    message.tokenId = object.tokenId ?? 0;
    message.amount = object.amount ?? 0n;
    message.accountId = object.accountId ?? 0;
    message.userCreated = object.userCreated ?? false;
    message.userPubkey = object.userPubkey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseReceipt_InsertTokenResult(): Receipt_InsertTokenResult {
  return { chainAddr: new Uint8Array(0), token: undefined };
}

export const Receipt_InsertTokenResult: MessageFns<Receipt_InsertTokenResult> = {
  encode(message: Receipt_InsertTokenResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainAddr.length !== 0) {
      writer.uint32(10).bytes(message.chainAddr);
    }
    if (message.token !== undefined) {
      Token.encode(message.token, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_InsertTokenResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_InsertTokenResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chainAddr = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = Token.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_InsertTokenResult {
    return {
      chainAddr: isSet(object.chainAddr) ? bytesFromBase64(object.chainAddr) : new Uint8Array(0),
      token: isSet(object.token) ? Token.fromJSON(object.token) : undefined,
    };
  },

  toJSON(message: Receipt_InsertTokenResult): unknown {
    const obj: any = {};
    if (message.chainAddr.length !== 0) {
      obj.chainAddr = base64FromBytes(message.chainAddr);
    }
    if (message.token !== undefined) {
      obj.token = Token.toJSON(message.token);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_InsertTokenResult>, I>>(base?: I): Receipt_InsertTokenResult {
    return Receipt_InsertTokenResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_InsertTokenResult>, I>>(object: I): Receipt_InsertTokenResult {
    const message = createBaseReceipt_InsertTokenResult();
    message.chainAddr = object.chainAddr ?? new Uint8Array(0);
    message.token = (object.token !== undefined && object.token !== null) ? Token.fromPartial(object.token) : undefined;
    return message;
  },
};

function createBaseReceipt_InsertMarketResult(): Receipt_InsertMarketResult {
  return { market: undefined };
}

export const Receipt_InsertMarketResult: MessageFns<Receipt_InsertMarketResult> = {
  encode(message: Receipt_InsertMarketResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.market !== undefined) {
      Market.encode(message.market, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_InsertMarketResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_InsertMarketResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.market = Market.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_InsertMarketResult {
    return { market: isSet(object.market) ? Market.fromJSON(object.market) : undefined };
  },

  toJSON(message: Receipt_InsertMarketResult): unknown {
    const obj: any = {};
    if (message.market !== undefined) {
      obj.market = Market.toJSON(message.market);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_InsertMarketResult>, I>>(base?: I): Receipt_InsertMarketResult {
    return Receipt_InsertMarketResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_InsertMarketResult>, I>>(object: I): Receipt_InsertMarketResult {
    const message = createBaseReceipt_InsertMarketResult();
    message.market = (object.market !== undefined && object.market !== null)
      ? Market.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseReceipt_WithdrawResult(): Receipt_WithdrawResult {
  return { tokenId: 0, amount: 0n, balance: 0n, accountId: 0, userPubkey: new Uint8Array(0) };
}

export const Receipt_WithdrawResult: MessageFns<Receipt_WithdrawResult> = {
  encode(message: Receipt_WithdrawResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tokenId !== 0) {
      writer.uint32(8).uint32(message.tokenId);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(16).uint64(message.amount);
    }
    if (message.balance !== 0n) {
      if (BigInt.asUintN(64, message.balance) !== message.balance) {
        throw new globalThis.Error("value provided for field message.balance of type uint64 too large");
      }
      writer.uint32(24).uint64(message.balance);
    }
    if (message.accountId !== 0) {
      writer.uint32(32).uint32(message.accountId);
    }
    if (message.userPubkey.length !== 0) {
      writer.uint32(42).bytes(message.userPubkey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_WithdrawResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_WithdrawResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.balance = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.accountId = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userPubkey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_WithdrawResult {
    return {
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
      balance: isSet(object.balance) ? BigInt(object.balance) : 0n,
      accountId: isSet(object.accountId) ? globalThis.Number(object.accountId) : 0,
      userPubkey: isSet(object.userPubkey) ? bytesFromBase64(object.userPubkey) : new Uint8Array(0),
    };
  },

  toJSON(message: Receipt_WithdrawResult): unknown {
    const obj: any = {};
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    if (message.balance !== 0n) {
      obj.balance = message.balance.toString();
    }
    if (message.accountId !== 0) {
      obj.accountId = Math.round(message.accountId);
    }
    if (message.userPubkey.length !== 0) {
      obj.userPubkey = base64FromBytes(message.userPubkey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_WithdrawResult>, I>>(base?: I): Receipt_WithdrawResult {
    return Receipt_WithdrawResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_WithdrawResult>, I>>(object: I): Receipt_WithdrawResult {
    const message = createBaseReceipt_WithdrawResult();
    message.tokenId = object.tokenId ?? 0;
    message.amount = object.amount ?? 0n;
    message.balance = object.balance ?? 0n;
    message.accountId = object.accountId ?? 0;
    message.userPubkey = object.userPubkey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseReceipt_OracleSymbolFeedResult(): Receipt_OracleSymbolFeedResult {
  return { oracleSymbol: "", feedId: new Uint8Array(0) };
}

export const Receipt_OracleSymbolFeedResult: MessageFns<Receipt_OracleSymbolFeedResult> = {
  encode(message: Receipt_OracleSymbolFeedResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oracleSymbol !== "") {
      writer.uint32(10).string(message.oracleSymbol);
    }
    if (message.feedId.length !== 0) {
      writer.uint32(18).bytes(message.feedId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_OracleSymbolFeedResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_OracleSymbolFeedResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oracleSymbol = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.feedId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_OracleSymbolFeedResult {
    return {
      oracleSymbol: isSet(object.oracleSymbol) ? globalThis.String(object.oracleSymbol) : "",
      feedId: isSet(object.feedId) ? bytesFromBase64(object.feedId) : new Uint8Array(0),
    };
  },

  toJSON(message: Receipt_OracleSymbolFeedResult): unknown {
    const obj: any = {};
    if (message.oracleSymbol !== "") {
      obj.oracleSymbol = message.oracleSymbol;
    }
    if (message.feedId.length !== 0) {
      obj.feedId = base64FromBytes(message.feedId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_OracleSymbolFeedResult>, I>>(base?: I): Receipt_OracleSymbolFeedResult {
    return Receipt_OracleSymbolFeedResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_OracleSymbolFeedResult>, I>>(
    object: I,
  ): Receipt_OracleSymbolFeedResult {
    const message = createBaseReceipt_OracleSymbolFeedResult();
    message.oracleSymbol = object.oracleSymbol ?? "";
    message.feedId = object.feedId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseReceipt_OracleUpdateResult(): Receipt_OracleUpdateResult {
  return { timestamp: 0n };
}

export const Receipt_OracleUpdateResult: MessageFns<Receipt_OracleUpdateResult> = {
  encode(message: Receipt_OracleUpdateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== 0n) {
      if (BigInt.asIntN(64, message.timestamp) !== message.timestamp) {
        throw new globalThis.Error("value provided for field message.timestamp of type int64 too large");
      }
      writer.uint32(8).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_OracleUpdateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_OracleUpdateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.int64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_OracleUpdateResult {
    return { timestamp: isSet(object.timestamp) ? BigInt(object.timestamp) : 0n };
  },

  toJSON(message: Receipt_OracleUpdateResult): unknown {
    const obj: any = {};
    if (message.timestamp !== 0n) {
      obj.timestamp = message.timestamp.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_OracleUpdateResult>, I>>(base?: I): Receipt_OracleUpdateResult {
    return Receipt_OracleUpdateResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_OracleUpdateResult>, I>>(object: I): Receipt_OracleUpdateResult {
    const message = createBaseReceipt_OracleUpdateResult();
    message.timestamp = object.timestamp ?? 0n;
    return message;
  },
};

function createBaseReceipt_UpdateGuardianSetResult(): Receipt_UpdateGuardianSetResult {
  return { guardianSetIndex: 0, addresses: [] };
}

export const Receipt_UpdateGuardianSetResult: MessageFns<Receipt_UpdateGuardianSetResult> = {
  encode(message: Receipt_UpdateGuardianSetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guardianSetIndex !== 0) {
      writer.uint32(8).uint32(message.guardianSetIndex);
    }
    for (const v of message.addresses) {
      writer.uint32(18).bytes(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_UpdateGuardianSetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_UpdateGuardianSetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.guardianSetIndex = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addresses.push(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_UpdateGuardianSetResult {
    return {
      guardianSetIndex: isSet(object.guardianSetIndex) ? globalThis.Number(object.guardianSetIndex) : 0,
      addresses: globalThis.Array.isArray(object?.addresses)
        ? object.addresses.map((e: any) => bytesFromBase64(e))
        : [],
    };
  },

  toJSON(message: Receipt_UpdateGuardianSetResult): unknown {
    const obj: any = {};
    if (message.guardianSetIndex !== 0) {
      obj.guardianSetIndex = Math.round(message.guardianSetIndex);
    }
    if (message.addresses?.length) {
      obj.addresses = message.addresses.map((e) => base64FromBytes(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_UpdateGuardianSetResult>, I>>(base?: I): Receipt_UpdateGuardianSetResult {
    return Receipt_UpdateGuardianSetResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_UpdateGuardianSetResult>, I>>(
    object: I,
  ): Receipt_UpdateGuardianSetResult {
    const message = createBaseReceipt_UpdateGuardianSetResult();
    message.guardianSetIndex = object.guardianSetIndex ?? 0;
    message.addresses = object.addresses?.map((e) => e) || [];
    return message;
  },
};

function createBaseReceipt_PerpPosition(): Receipt_PerpPosition {
  return { marketId: 0, baseSize: 0n, price: 0n };
}

export const Receipt_PerpPosition: MessageFns<Receipt_PerpPosition> = {
  encode(message: Receipt_PerpPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.baseSize !== 0n) {
      if (BigInt.asIntN(64, message.baseSize) !== message.baseSize) {
        throw new globalThis.Error("value provided for field message.baseSize of type int64 too large");
      }
      writer.uint32(16).int64(message.baseSize);
    }
    if (message.price !== 0n) {
      if (BigInt.asUintN(64, message.price) !== message.price) {
        throw new globalThis.Error("value provided for field message.price of type uint64 too large");
      }
      writer.uint32(24).uint64(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_PerpPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_PerpPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.baseSize = reader.int64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.price = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_PerpPosition {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      baseSize: isSet(object.baseSize) ? BigInt(object.baseSize) : 0n,
      price: isSet(object.price) ? BigInt(object.price) : 0n,
    };
  },

  toJSON(message: Receipt_PerpPosition): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.baseSize !== 0n) {
      obj.baseSize = message.baseSize.toString();
    }
    if (message.price !== 0n) {
      obj.price = message.price.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_PerpPosition>, I>>(base?: I): Receipt_PerpPosition {
    return Receipt_PerpPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_PerpPosition>, I>>(object: I): Receipt_PerpPosition {
    const message = createBaseReceipt_PerpPosition();
    message.marketId = object.marketId ?? 0;
    message.baseSize = object.baseSize ?? 0n;
    message.price = object.price ?? 0n;
    return message;
  },
};

function createBaseReceipt_AccountLiquidated(): Receipt_AccountLiquidated {
  return { liquidatorAccountId: 0, liquidateeAccountId: 0, cancelledOrders: [], removedPerps: [] };
}

export const Receipt_AccountLiquidated: MessageFns<Receipt_AccountLiquidated> = {
  encode(message: Receipt_AccountLiquidated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.liquidatorAccountId !== 0) {
      writer.uint32(8).uint32(message.liquidatorAccountId);
    }
    if (message.liquidateeAccountId !== 0) {
      writer.uint32(16).uint32(message.liquidateeAccountId);
    }
    writer.uint32(26).fork();
    for (const v of message.cancelledOrders) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field cancelledOrders of type uint64 is too large");
      }
      writer.uint64(v);
    }
    writer.join();
    for (const v of message.removedPerps) {
      Receipt_PerpPosition.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_AccountLiquidated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_AccountLiquidated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.liquidatorAccountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.liquidateeAccountId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.cancelledOrders.push(reader.uint64() as bigint);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cancelledOrders.push(reader.uint64() as bigint);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.removedPerps.push(Receipt_PerpPosition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_AccountLiquidated {
    return {
      liquidatorAccountId: isSet(object.liquidatorAccountId) ? globalThis.Number(object.liquidatorAccountId) : 0,
      liquidateeAccountId: isSet(object.liquidateeAccountId) ? globalThis.Number(object.liquidateeAccountId) : 0,
      cancelledOrders: globalThis.Array.isArray(object?.cancelledOrders)
        ? object.cancelledOrders.map((e: any) => BigInt(e))
        : [],
      removedPerps: globalThis.Array.isArray(object?.removedPerps)
        ? object.removedPerps.map((e: any) => Receipt_PerpPosition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Receipt_AccountLiquidated): unknown {
    const obj: any = {};
    if (message.liquidatorAccountId !== 0) {
      obj.liquidatorAccountId = Math.round(message.liquidatorAccountId);
    }
    if (message.liquidateeAccountId !== 0) {
      obj.liquidateeAccountId = Math.round(message.liquidateeAccountId);
    }
    if (message.cancelledOrders?.length) {
      obj.cancelledOrders = message.cancelledOrders.map((e) => e.toString());
    }
    if (message.removedPerps?.length) {
      obj.removedPerps = message.removedPerps.map((e) => Receipt_PerpPosition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_AccountLiquidated>, I>>(base?: I): Receipt_AccountLiquidated {
    return Receipt_AccountLiquidated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_AccountLiquidated>, I>>(object: I): Receipt_AccountLiquidated {
    const message = createBaseReceipt_AccountLiquidated();
    message.liquidatorAccountId = object.liquidatorAccountId ?? 0;
    message.liquidateeAccountId = object.liquidateeAccountId ?? 0;
    message.cancelledOrders = object.cancelledOrders?.map((e) => e) || [];
    message.removedPerps = object.removedPerps?.map((e) => Receipt_PerpPosition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReceipt_SessionRevoked(): Receipt_SessionRevoked {
  return {};
}

export const Receipt_SessionRevoked: MessageFns<Receipt_SessionRevoked> = {
  encode(_: Receipt_SessionRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_SessionRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_SessionRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Receipt_SessionRevoked {
    return {};
  },

  toJSON(_: Receipt_SessionRevoked): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_SessionRevoked>, I>>(base?: I): Receipt_SessionRevoked {
    return Receipt_SessionRevoked.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_SessionRevoked>, I>>(_: I): Receipt_SessionRevoked {
    const message = createBaseReceipt_SessionRevoked();
    return message;
  },
};

function createBaseReceipt_Paused(): Receipt_Paused {
  return {};
}

export const Receipt_Paused: MessageFns<Receipt_Paused> = {
  encode(_: Receipt_Paused, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_Paused {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_Paused();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Receipt_Paused {
    return {};
  },

  toJSON(_: Receipt_Paused): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_Paused>, I>>(base?: I): Receipt_Paused {
    return Receipt_Paused.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_Paused>, I>>(_: I): Receipt_Paused {
    const message = createBaseReceipt_Paused();
    return message;
  },
};

function createBaseReceipt_Unpaused(): Receipt_Unpaused {
  return {};
}

export const Receipt_Unpaused: MessageFns<Receipt_Unpaused> = {
  encode(_: Receipt_Unpaused, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_Unpaused {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_Unpaused();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Receipt_Unpaused {
    return {};
  },

  toJSON(_: Receipt_Unpaused): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_Unpaused>, I>>(base?: I): Receipt_Unpaused {
    return Receipt_Unpaused.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_Unpaused>, I>>(_: I): Receipt_Unpaused {
    const message = createBaseReceipt_Unpaused();
    return message;
  },
};

function createBaseReceipt_Transferred(): Receipt_Transferred {
  return {
    fromAccountId: 0,
    toUserAccount: undefined,
    tokenId: 0,
    amount: 0n,
    accountCreated: false,
    toSpecialAccount: undefined,
  };
}

export const Receipt_Transferred: MessageFns<Receipt_Transferred> = {
  encode(message: Receipt_Transferred, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fromAccountId !== 0) {
      writer.uint32(8).uint32(message.fromAccountId);
    }
    if (message.toUserAccount !== undefined) {
      writer.uint32(16).uint32(message.toUserAccount);
    }
    if (message.tokenId !== 0) {
      writer.uint32(24).uint32(message.tokenId);
    }
    if (message.amount !== 0n) {
      if (BigInt.asUintN(64, message.amount) !== message.amount) {
        throw new globalThis.Error("value provided for field message.amount of type uint64 too large");
      }
      writer.uint32(32).uint64(message.amount);
    }
    if (message.accountCreated !== false) {
      writer.uint32(40).bool(message.accountCreated);
    }
    if (message.toSpecialAccount !== undefined) {
      writer.uint32(48).int32(message.toSpecialAccount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_Transferred {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_Transferred();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fromAccountId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.toUserAccount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tokenId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.accountCreated = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.toSpecialAccount = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receipt_Transferred {
    return {
      fromAccountId: isSet(object.fromAccountId) ? globalThis.Number(object.fromAccountId) : 0,
      toUserAccount: isSet(object.toUserAccount) ? globalThis.Number(object.toUserAccount) : undefined,
      tokenId: isSet(object.tokenId) ? globalThis.Number(object.tokenId) : 0,
      amount: isSet(object.amount) ? BigInt(object.amount) : 0n,
      accountCreated: isSet(object.accountCreated) ? globalThis.Boolean(object.accountCreated) : false,
      toSpecialAccount: isSet(object.toSpecialAccount) ? specialAccountFromJSON(object.toSpecialAccount) : undefined,
    };
  },

  toJSON(message: Receipt_Transferred): unknown {
    const obj: any = {};
    if (message.fromAccountId !== 0) {
      obj.fromAccountId = Math.round(message.fromAccountId);
    }
    if (message.toUserAccount !== undefined) {
      obj.toUserAccount = Math.round(message.toUserAccount);
    }
    if (message.tokenId !== 0) {
      obj.tokenId = Math.round(message.tokenId);
    }
    if (message.amount !== 0n) {
      obj.amount = message.amount.toString();
    }
    if (message.accountCreated !== false) {
      obj.accountCreated = message.accountCreated;
    }
    if (message.toSpecialAccount !== undefined) {
      obj.toSpecialAccount = specialAccountToJSON(message.toSpecialAccount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_Transferred>, I>>(base?: I): Receipt_Transferred {
    return Receipt_Transferred.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_Transferred>, I>>(object: I): Receipt_Transferred {
    const message = createBaseReceipt_Transferred();
    message.fromAccountId = object.fromAccountId ?? 0;
    message.toUserAccount = object.toUserAccount ?? undefined;
    message.tokenId = object.tokenId ?? 0;
    message.amount = object.amount ?? 0n;
    message.accountCreated = object.accountCreated ?? false;
    message.toSpecialAccount = object.toSpecialAccount ?? undefined;
    return message;
  },
};

function createBaseReceipt_TriggerAdded(): Receipt_TriggerAdded {
  return {};
}

export const Receipt_TriggerAdded: MessageFns<Receipt_TriggerAdded> = {
  encode(_: Receipt_TriggerAdded, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_TriggerAdded {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_TriggerAdded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Receipt_TriggerAdded {
    return {};
  },

  toJSON(_: Receipt_TriggerAdded): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_TriggerAdded>, I>>(base?: I): Receipt_TriggerAdded {
    return Receipt_TriggerAdded.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_TriggerAdded>, I>>(_: I): Receipt_TriggerAdded {
    const message = createBaseReceipt_TriggerAdded();
    return message;
  },
};

function createBaseReceipt_TriggerRemoved(): Receipt_TriggerRemoved {
  return {};
}

export const Receipt_TriggerRemoved: MessageFns<Receipt_TriggerRemoved> = {
  encode(_: Receipt_TriggerRemoved, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receipt_TriggerRemoved {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceipt_TriggerRemoved();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Receipt_TriggerRemoved {
    return {};
  },

  toJSON(_: Receipt_TriggerRemoved): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Receipt_TriggerRemoved>, I>>(base?: I): Receipt_TriggerRemoved {
    return Receipt_TriggerRemoved.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receipt_TriggerRemoved>, I>>(_: I): Receipt_TriggerRemoved {
    const message = createBaseReceipt_TriggerRemoved();
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string; value: unknown } ? { $case: T["$case"]; value?: DeepPartial<T["value"]> }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
